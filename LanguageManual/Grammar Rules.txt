program -> methods
methods -> methods method | method

method -> DATATYPE FUNCNAME ( params ) { statements }
statements -> statement statements | e //not sure if this epsilon will cause issues - this leads to empty blocks
params -> DATATYPE VARNAME, params | e

✓ statement -> declaration_statement SEMICOL | assignment_statement SEMICOL | io_statement SEMICOL | jump_statement SEMICOL | selection_statement | iteration_statement

declaration_statement -> simple_init | array_init
simple_init -> DATATYPE VARNAME | DATATYPE VARNAME = expr

array_init -> DATATYPE VARNAME [INTVAL] = { array_list } | DATATYPE VARNAME [INTVAL? ] [INTVAL] = { array_list } 
array_list = constant, array_list | constant

✓ constant -> INTVAL | FLOATVAL | CHARVAL | STRINGVAL | BOOLVAL

✓ arr_variable -> VARNAME [INTVAL] | VARNAME [INTVAL][INTVAL] | VARNAME [VARNAME] | VARNAME [VARNAME][VARNAME] | VARNAME [INTVAL][VARNAME] | VARNAME [VARNAME][INTVAL]
✓ assignment_statement -> left_value = expr
✓ left_value -> VARNAME | array_variable


✓ io_statement -> input_statement | output_statement
✓ input_statement -> INPUT ( left_value )
✓ output_statement -> OUTPUT ( left_value ) | OUTPUT ( constant )

selection_statement -> if_statement | switch_statement
if_statement -> IF ( expr ) { statements } | IF ( expr ) { statements} ELSE { statements} | IF ( expr ) { statements} elif | IF ( expr ) { statements} elif ELSE { statements}
elif -> ELIF ( expr ) { statements } elif | ELIF ( expr ) { statements }

switch_statement -> SWITCH ( left_value ) { case_statements }
case_statements -> case_statement case_statements | case_statement | default_statement
case_statement -> CASE ( constant ) COLON statements 
default_statement -> DEFAULT COLON statements

interation_statement -> while_statement | for_statement
while_statement -> WHILE ( expr ) { statements }
for_statement -> FOR ( for_init ; expr ; assignment_statement ) { statements }
for_init -> DATATYPE VARNAME = expr | VARNAME = expr

✓ jump_statement -> BREAK | return_statement
✓ return_statement -> RETURN expr | RETURN

✓ expr -> expr PLUS expr | expr MINUS expr | expr MULT expr | expr DIVIDE expr | expr MOD expr | MINUS expr %prec UMINUS
        | (expr) %prec PAREN | function_call | expr RELOP1 expr | expr RELOP2 expr | expr AND expr | expr OR expr | NOT expr | VARNAME
        | array_variable | constant | (DATATYPE) expr %prec TYPECASTING


✓ function_call -> VARNAME ( argument_list )
argument_list -> expr, argument_list | e

TODO:
Look into symbol table implementation 
Let us all write exhaustive unit test cases for theoretical testing
Testing for ambiguity with empty function bodies

Left factor it?
We'll have more rules - but we wont have any ambiguity in the


int i = 5;
if(i>4)
{ 
        
        for(int j-0; j<10; j++)
        { statements}
        if(i>1)
        { int i = 8;
          print(i); //8
        }
        else
        { print(i); //5
        }
        print(i); //5

}

#  -----------------------------

Problems :
1. Grammar requires semicolon after if block     (solved)
2. expr -> -(expr) instead of expr -> - expr     (working fine)
3. expr -> expr AND expr : TAC for this
4. When used expr -> expr && expr , throws Sysntax error
5. change INTVAL to expr in array_variable


TAC generation:
for expr
variable usage

c = (a+b)+(c+d)

t0 = c+d
t1 = a+b
t2 = t0 + t1
c = t2

c = a+b+c



t0 = a+b
t1 = t0+c
c = t1




