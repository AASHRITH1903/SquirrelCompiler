Grammar:

Rule 0     S' -> program
Rule 1     program -> methods
Rule 2     methods -> method
Rule 3     methods -> methods method
Rule 4     method -> DATATYPE FUNCNAME LPAREN params RPAREN LBRACE statements RBRACE
Rule 5     params -> empty
Rule 6     params -> DATATYPE VARNAME COMMA params  [precedence=left, level=1]
Rule 7     statements -> empty
Rule 8     statements -> statements statement
Rule 9     statement -> selection_statement
Rule 10    statement -> io_statement SEMICOL
Rule 11    statement -> assignment_statement SEMICOL
Rule 12    statement -> declaration_statement SEMICOL
Rule 13    selection_statement -> if_statement
Rule 14    declaration_statement -> simple_init
Rule 15    simple_init -> DATATYPE VARNAME
Rule 16    if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE
Rule 17    io_statement -> output_statement
Rule 18    io_statement -> input_statement
Rule 19    input_statement -> INPUT LPAREN left_value RPAREN
Rule 20    output_statement -> OUTPUT LPAREN constant RPAREN
Rule 21    output_statement -> OUTPUT LPAREN left_value RPAREN
Rule 22    jump_statement -> return_statement
Rule 23    jump_statement -> BREAK
Rule 24    return_statement -> RETURN
Rule 25    return_statement -> RETURN expr
Rule 26    expr -> function_call
Rule 27    expr -> LPAREN DATATYPE RPAREN expr  [precedence=right, level=9]
Rule 28    expr -> constant
Rule 29    expr -> VARNAME
Rule 30    expr -> NOT expr  [precedence=right, level=10]
Rule 31    expr -> expr OR expr  [precedence=left, level=3]
Rule 32    expr -> expr AND expr  [precedence=left, level=4]
Rule 33    expr -> expr RELOP2 expr  [precedence=left, level=5]
Rule 34    expr -> expr RELOP1 expr  [precedence=left, level=6]
Rule 35    expr -> LPAREN expr RPAREN  [precedence=right, level=11]
Rule 36    expr -> MINUS expr  [precedence=right, level=10]
Rule 37    expr -> expr MOD expr  [precedence=left, level=8]
Rule 38    expr -> expr DIVIDE expr  [precedence=left, level=8]
Rule 39    expr -> expr MULT expr  [precedence=left, level=8]
Rule 40    expr -> expr MINUS expr  [precedence=left, level=7]
Rule 41    expr -> expr PLUS expr  [precedence=left, level=7]
Rule 42    b1_open -> COMMA  [precedence=left, level=1]
Rule 43    b2_open -> <empty>
Rule 44    array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
Rule 45    array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
Rule 46    array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
Rule 47    array_variable -> VARNAME LSQB VARNAME RSQB
Rule 48    array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
Rule 49    array_variable -> VARNAME LSQB INTVAL RSQB
Rule 50    assignment_statement -> left_value ASSIGN expr  [precedence=right, level=2]
Rule 51    left_value -> array_variable
Rule 52    left_value -> VARNAME
Rule 53    constant -> BOOLVAL
Rule 54    constant -> STRINGVAL
Rule 55    constant -> CHARVAL
Rule 56    constant -> FLOATVAL
Rule 57    constant -> INTVAL
Rule 58    function_call -> VARNAME LPAREN argument_list RPAREN
Rule 59    argument_list -> argument
Rule 60    argument_list -> argument COMMA argument_list  [precedence=left, level=1]
Rule 61    argument -> array_variable
Rule 62    argument -> constant
Rule 63    argument -> VARNAME
Rule 64    empty -> <empty>

Unused terminals:

    DEFAULT
    COLON
    SWITCH
    CASE
    FOR
    ELSE
    ELIF
    FUZZY
    WHILE

Terminals, with rules where they appear:

AND                  : 32
ASSIGN               : 50
BOOLVAL              : 53
BREAK                : 23
CASE                 : 
CHARVAL              : 55
COLON                : 
COMMA                : 6 42 60
DATATYPE             : 4 6 15 27
DEFAULT              : 
DIVIDE               : 38
ELIF                 : 
ELSE                 : 
FLOATVAL             : 56
FOR                  : 
FUNCNAME             : 4
FUZZY                : 
IF                   : 16
INPUT                : 19
INTVAL               : 45 46 48 48 49 57
LBRACE               : 4 16
LPAREN               : 4 16 19 20 21 27 35 58
LSQB                 : 44 44 45 45 46 46 47 48 48 49
MINUS                : 36 40
MOD                  : 37
MULT                 : 39
NOT                  : 30
OR                   : 31
OUTPUT               : 20 21
PLUS                 : 41
RBRACE               : 4 16
RELOP1               : 34
RELOP2               : 33
RETURN               : 24 25
RPAREN               : 4 16 19 20 21 27 35 58
RSQB                 : 44 44 45 45 46 46 47 48 48 49
SEMICOL              : 10 11 12
STRINGVAL            : 54
SWITCH               : 
VARNAME              : 6 15 29 44 44 44 45 45 46 46 47 47 48 49 52 58 63
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

argument             : 59 60
argument_list        : 58 60
array_variable       : 51 61
assignment_statement : 11
b1_open              : 
b2_open              : 
constant             : 20 28 62
declaration_statement : 12
empty                : 5 7
expr                 : 16 25 27 30 31 31 32 32 33 33 34 34 35 36 37 37 38 38 39 39 40 40 41 41 50
function_call        : 26
if_statement         : 13
input_statement      : 18
io_statement         : 10
jump_statement       : 
left_value           : 19 21 50
method               : 2 3
methods              : 1 3
output_statement     : 17
params               : 4 6
program              : 0
return_statement     : 22
selection_statement  : 9
simple_init          : 14
statement            : 8
statements           : 4 8 16


state 0

    (0) S' -> . program
    (1) program -> . methods
    (2) methods -> . method
    (3) methods -> . methods method
    (4) method -> . DATATYPE FUNCNAME LPAREN params RPAREN LBRACE statements RBRACE
    DATATYPE        shift and go to state 4

    program                        shift and go to state 1
    methods                        shift and go to state 2
    method                         shift and go to state 3

state 1

    (0) S' -> program .


state 2

    (1) program -> methods .
    (3) methods -> methods . method
    (4) method -> . DATATYPE FUNCNAME LPAREN params RPAREN LBRACE statements RBRACE
    $end            reduce using rule 1 (program -> methods .)
    DATATYPE        shift and go to state 4

    method                         shift and go to state 5

state 3

    (2) methods -> method .
    DATATYPE        reduce using rule 2 (methods -> method .)
    $end            reduce using rule 2 (methods -> method .)


state 4

    (4) method -> DATATYPE . FUNCNAME LPAREN params RPAREN LBRACE statements RBRACE
    FUNCNAME        shift and go to state 6


state 5

    (3) methods -> methods method .
    DATATYPE        reduce using rule 3 (methods -> methods method .)
    $end            reduce using rule 3 (methods -> methods method .)


state 6

    (4) method -> DATATYPE FUNCNAME . LPAREN params RPAREN LBRACE statements RBRACE
    LPAREN          shift and go to state 7


state 7

    (4) method -> DATATYPE FUNCNAME LPAREN . params RPAREN LBRACE statements RBRACE
    (5) params -> . empty
    (6) params -> . DATATYPE VARNAME COMMA params
    (64) empty -> .
    DATATYPE        shift and go to state 8
    RPAREN          reduce using rule 64 (empty -> .)

    params                         shift and go to state 9
    empty                          shift and go to state 10

state 8

    (6) params -> DATATYPE . VARNAME COMMA params
    VARNAME         shift and go to state 11


state 9

    (4) method -> DATATYPE FUNCNAME LPAREN params . RPAREN LBRACE statements RBRACE
    RPAREN          shift and go to state 12


state 10

    (5) params -> empty .
    RPAREN          reduce using rule 5 (params -> empty .)


state 11

    (6) params -> DATATYPE VARNAME . COMMA params
    COMMA           shift and go to state 13


state 12

    (4) method -> DATATYPE FUNCNAME LPAREN params RPAREN . LBRACE statements RBRACE
    LBRACE          shift and go to state 14


state 13

    (6) params -> DATATYPE VARNAME COMMA . params
    (5) params -> . empty
    (6) params -> . DATATYPE VARNAME COMMA params
    (64) empty -> .
    DATATYPE        shift and go to state 8
    RPAREN          reduce using rule 64 (empty -> .)

    params                         shift and go to state 15
    empty                          shift and go to state 10

state 14

    (4) method -> DATATYPE FUNCNAME LPAREN params RPAREN LBRACE . statements RBRACE
    (7) statements -> . empty
    (8) statements -> . statements statement
    (64) empty -> .
    RBRACE          reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    OUTPUT          reduce using rule 64 (empty -> .)
    INPUT           reduce using rule 64 (empty -> .)
    VARNAME         reduce using rule 64 (empty -> .)
    DATATYPE        reduce using rule 64 (empty -> .)

    statements                     shift and go to state 16
    empty                          shift and go to state 17

state 15

    (6) params -> DATATYPE VARNAME COMMA params .
    RPAREN          reduce using rule 6 (params -> DATATYPE VARNAME COMMA params .)


state 16

    (4) method -> DATATYPE FUNCNAME LPAREN params RPAREN LBRACE statements . RBRACE
    (8) statements -> statements . statement
    (9) statement -> . selection_statement
    (10) statement -> . io_statement SEMICOL
    (11) statement -> . assignment_statement SEMICOL
    (12) statement -> . declaration_statement SEMICOL
    (13) selection_statement -> . if_statement
    (17) io_statement -> . output_statement
    (18) io_statement -> . input_statement
    (50) assignment_statement -> . left_value ASSIGN expr
    (14) declaration_statement -> . simple_init
    (16) if_statement -> . IF LPAREN expr RPAREN LBRACE statements RBRACE
    (20) output_statement -> . OUTPUT LPAREN constant RPAREN
    (21) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (19) input_statement -> . INPUT LPAREN left_value RPAREN
    (51) left_value -> . array_variable
    (52) left_value -> . VARNAME
    (15) simple_init -> . DATATYPE VARNAME
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB VARNAME RSQB
    (48) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> . VARNAME LSQB INTVAL RSQB
    RBRACE          shift and go to state 19
    IF              shift and go to state 30
    OUTPUT          shift and go to state 31
    INPUT           shift and go to state 32
    VARNAME         shift and go to state 34
    DATATYPE        shift and go to state 18

    statement                      shift and go to state 20
    selection_statement            shift and go to state 21
    io_statement                   shift and go to state 22
    assignment_statement           shift and go to state 23
    declaration_statement          shift and go to state 24
    if_statement                   shift and go to state 25
    output_statement               shift and go to state 26
    input_statement                shift and go to state 27
    left_value                     shift and go to state 28
    simple_init                    shift and go to state 29
    array_variable                 shift and go to state 33

state 17

    (7) statements -> empty .
    RBRACE          reduce using rule 7 (statements -> empty .)
    IF              reduce using rule 7 (statements -> empty .)
    OUTPUT          reduce using rule 7 (statements -> empty .)
    INPUT           reduce using rule 7 (statements -> empty .)
    VARNAME         reduce using rule 7 (statements -> empty .)
    DATATYPE        reduce using rule 7 (statements -> empty .)


state 18

    (15) simple_init -> DATATYPE . VARNAME
    VARNAME         shift and go to state 35


state 19

    (4) method -> DATATYPE FUNCNAME LPAREN params RPAREN LBRACE statements RBRACE .
    DATATYPE        reduce using rule 4 (method -> DATATYPE FUNCNAME LPAREN params RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 4 (method -> DATATYPE FUNCNAME LPAREN params RPAREN LBRACE statements RBRACE .)


state 20

    (8) statements -> statements statement .
    RBRACE          reduce using rule 8 (statements -> statements statement .)
    IF              reduce using rule 8 (statements -> statements statement .)
    OUTPUT          reduce using rule 8 (statements -> statements statement .)
    INPUT           reduce using rule 8 (statements -> statements statement .)
    VARNAME         reduce using rule 8 (statements -> statements statement .)
    DATATYPE        reduce using rule 8 (statements -> statements statement .)


state 21

    (9) statement -> selection_statement .
    RBRACE          reduce using rule 9 (statement -> selection_statement .)
    IF              reduce using rule 9 (statement -> selection_statement .)
    OUTPUT          reduce using rule 9 (statement -> selection_statement .)
    INPUT           reduce using rule 9 (statement -> selection_statement .)
    VARNAME         reduce using rule 9 (statement -> selection_statement .)
    DATATYPE        reduce using rule 9 (statement -> selection_statement .)


state 22

    (10) statement -> io_statement . SEMICOL
    SEMICOL         shift and go to state 36


state 23

    (11) statement -> assignment_statement . SEMICOL
    SEMICOL         shift and go to state 37


state 24

    (12) statement -> declaration_statement . SEMICOL
    SEMICOL         shift and go to state 38


state 25

    (13) selection_statement -> if_statement .
    RBRACE          reduce using rule 13 (selection_statement -> if_statement .)
    IF              reduce using rule 13 (selection_statement -> if_statement .)
    OUTPUT          reduce using rule 13 (selection_statement -> if_statement .)
    INPUT           reduce using rule 13 (selection_statement -> if_statement .)
    VARNAME         reduce using rule 13 (selection_statement -> if_statement .)
    DATATYPE        reduce using rule 13 (selection_statement -> if_statement .)


state 26

    (17) io_statement -> output_statement .
    SEMICOL         reduce using rule 17 (io_statement -> output_statement .)


state 27

    (18) io_statement -> input_statement .
    SEMICOL         reduce using rule 18 (io_statement -> input_statement .)


state 28

    (50) assignment_statement -> left_value . ASSIGN expr
    ASSIGN          shift and go to state 39


state 29

    (14) declaration_statement -> simple_init .
    SEMICOL         reduce using rule 14 (declaration_statement -> simple_init .)


state 30

    (16) if_statement -> IF . LPAREN expr RPAREN LBRACE statements RBRACE
    LPAREN          shift and go to state 40


state 31

    (20) output_statement -> OUTPUT . LPAREN constant RPAREN
    (21) output_statement -> OUTPUT . LPAREN left_value RPAREN
    LPAREN          shift and go to state 41


state 32

    (19) input_statement -> INPUT . LPAREN left_value RPAREN
    LPAREN          shift and go to state 42


state 33

    (51) left_value -> array_variable .
    ASSIGN          reduce using rule 51 (left_value -> array_variable .)
    RPAREN          reduce using rule 51 (left_value -> array_variable .)


state 34

    (52) left_value -> VARNAME .
    (44) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME . LSQB VARNAME RSQB
    (48) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> VARNAME . LSQB INTVAL RSQB
    ASSIGN          reduce using rule 52 (left_value -> VARNAME .)
    RPAREN          reduce using rule 52 (left_value -> VARNAME .)
    LSQB            shift and go to state 43


state 35

    (15) simple_init -> DATATYPE VARNAME .
    SEMICOL         reduce using rule 15 (simple_init -> DATATYPE VARNAME .)


state 36

    (10) statement -> io_statement SEMICOL .
    RBRACE          reduce using rule 10 (statement -> io_statement SEMICOL .)
    IF              reduce using rule 10 (statement -> io_statement SEMICOL .)
    OUTPUT          reduce using rule 10 (statement -> io_statement SEMICOL .)
    INPUT           reduce using rule 10 (statement -> io_statement SEMICOL .)
    VARNAME         reduce using rule 10 (statement -> io_statement SEMICOL .)
    DATATYPE        reduce using rule 10 (statement -> io_statement SEMICOL .)


state 37

    (11) statement -> assignment_statement SEMICOL .
    RBRACE          reduce using rule 11 (statement -> assignment_statement SEMICOL .)
    IF              reduce using rule 11 (statement -> assignment_statement SEMICOL .)
    OUTPUT          reduce using rule 11 (statement -> assignment_statement SEMICOL .)
    INPUT           reduce using rule 11 (statement -> assignment_statement SEMICOL .)
    VARNAME         reduce using rule 11 (statement -> assignment_statement SEMICOL .)
    DATATYPE        reduce using rule 11 (statement -> assignment_statement SEMICOL .)


state 38

    (12) statement -> declaration_statement SEMICOL .
    RBRACE          reduce using rule 12 (statement -> declaration_statement SEMICOL .)
    IF              reduce using rule 12 (statement -> declaration_statement SEMICOL .)
    OUTPUT          reduce using rule 12 (statement -> declaration_statement SEMICOL .)
    INPUT           reduce using rule 12 (statement -> declaration_statement SEMICOL .)
    VARNAME         reduce using rule 12 (statement -> declaration_statement SEMICOL .)
    DATATYPE        reduce using rule 12 (statement -> declaration_statement SEMICOL .)


state 39

    (50) assignment_statement -> left_value ASSIGN . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 44
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 40

    (16) if_statement -> IF LPAREN . expr RPAREN LBRACE statements RBRACE
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 56
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 41

    (20) output_statement -> OUTPUT LPAREN . constant RPAREN
    (21) output_statement -> OUTPUT LPAREN . left_value RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    (51) left_value -> . array_variable
    (52) left_value -> . VARNAME
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB VARNAME RSQB
    (48) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> . VARNAME LSQB INTVAL RSQB
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55
    VARNAME         shift and go to state 34

    constant                       shift and go to state 57
    left_value                     shift and go to state 58
    array_variable                 shift and go to state 33

state 42

    (19) input_statement -> INPUT LPAREN . left_value RPAREN
    (51) left_value -> . array_variable
    (52) left_value -> . VARNAME
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB VARNAME RSQB
    (48) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> . VARNAME LSQB INTVAL RSQB
    VARNAME         shift and go to state 34

    left_value                     shift and go to state 59
    array_variable                 shift and go to state 33

state 43

    (44) array_variable -> VARNAME LSQB . VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> VARNAME LSQB . INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> VARNAME LSQB . VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME LSQB . VARNAME RSQB
    (48) array_variable -> VARNAME LSQB . INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> VARNAME LSQB . INTVAL RSQB
    VARNAME         shift and go to state 60
    INTVAL          shift and go to state 61


state 44

    (50) assignment_statement -> left_value ASSIGN expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    SEMICOL         reduce using rule 50 (assignment_statement -> left_value ASSIGN expr .)
    OR              shift and go to state 62
    AND             shift and go to state 63
    RELOP2          shift and go to state 64
    RELOP1          shift and go to state 65
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68
    MINUS           shift and go to state 69
    PLUS            shift and go to state 70


state 45

    (26) expr -> function_call .
    OR              reduce using rule 26 (expr -> function_call .)
    AND             reduce using rule 26 (expr -> function_call .)
    RELOP2          reduce using rule 26 (expr -> function_call .)
    RELOP1          reduce using rule 26 (expr -> function_call .)
    MOD             reduce using rule 26 (expr -> function_call .)
    DIVIDE          reduce using rule 26 (expr -> function_call .)
    MULT            reduce using rule 26 (expr -> function_call .)
    MINUS           reduce using rule 26 (expr -> function_call .)
    PLUS            reduce using rule 26 (expr -> function_call .)
    SEMICOL         reduce using rule 26 (expr -> function_call .)
    RPAREN          reduce using rule 26 (expr -> function_call .)


state 46

    (27) expr -> LPAREN . DATATYPE RPAREN expr
    (35) expr -> LPAREN . expr RPAREN
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    DATATYPE        shift and go to state 71
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 72
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 47

    (28) expr -> constant .
    OR              reduce using rule 28 (expr -> constant .)
    AND             reduce using rule 28 (expr -> constant .)
    RELOP2          reduce using rule 28 (expr -> constant .)
    RELOP1          reduce using rule 28 (expr -> constant .)
    MOD             reduce using rule 28 (expr -> constant .)
    DIVIDE          reduce using rule 28 (expr -> constant .)
    MULT            reduce using rule 28 (expr -> constant .)
    MINUS           reduce using rule 28 (expr -> constant .)
    PLUS            reduce using rule 28 (expr -> constant .)
    SEMICOL         reduce using rule 28 (expr -> constant .)
    RPAREN          reduce using rule 28 (expr -> constant .)


state 48

    (29) expr -> VARNAME .
    (58) function_call -> VARNAME . LPAREN argument_list RPAREN
    OR              reduce using rule 29 (expr -> VARNAME .)
    AND             reduce using rule 29 (expr -> VARNAME .)
    RELOP2          reduce using rule 29 (expr -> VARNAME .)
    RELOP1          reduce using rule 29 (expr -> VARNAME .)
    MOD             reduce using rule 29 (expr -> VARNAME .)
    DIVIDE          reduce using rule 29 (expr -> VARNAME .)
    MULT            reduce using rule 29 (expr -> VARNAME .)
    MINUS           reduce using rule 29 (expr -> VARNAME .)
    PLUS            reduce using rule 29 (expr -> VARNAME .)
    SEMICOL         reduce using rule 29 (expr -> VARNAME .)
    RPAREN          reduce using rule 29 (expr -> VARNAME .)
    LPAREN          shift and go to state 73


state 49

    (30) expr -> NOT . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 74
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 50

    (36) expr -> MINUS . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 75
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 51

    (53) constant -> BOOLVAL .
    OR              reduce using rule 53 (constant -> BOOLVAL .)
    AND             reduce using rule 53 (constant -> BOOLVAL .)
    RELOP2          reduce using rule 53 (constant -> BOOLVAL .)
    RELOP1          reduce using rule 53 (constant -> BOOLVAL .)
    MOD             reduce using rule 53 (constant -> BOOLVAL .)
    DIVIDE          reduce using rule 53 (constant -> BOOLVAL .)
    MULT            reduce using rule 53 (constant -> BOOLVAL .)
    MINUS           reduce using rule 53 (constant -> BOOLVAL .)
    PLUS            reduce using rule 53 (constant -> BOOLVAL .)
    SEMICOL         reduce using rule 53 (constant -> BOOLVAL .)
    RPAREN          reduce using rule 53 (constant -> BOOLVAL .)
    COMMA           reduce using rule 53 (constant -> BOOLVAL .)


state 52

    (54) constant -> STRINGVAL .
    OR              reduce using rule 54 (constant -> STRINGVAL .)
    AND             reduce using rule 54 (constant -> STRINGVAL .)
    RELOP2          reduce using rule 54 (constant -> STRINGVAL .)
    RELOP1          reduce using rule 54 (constant -> STRINGVAL .)
    MOD             reduce using rule 54 (constant -> STRINGVAL .)
    DIVIDE          reduce using rule 54 (constant -> STRINGVAL .)
    MULT            reduce using rule 54 (constant -> STRINGVAL .)
    MINUS           reduce using rule 54 (constant -> STRINGVAL .)
    PLUS            reduce using rule 54 (constant -> STRINGVAL .)
    SEMICOL         reduce using rule 54 (constant -> STRINGVAL .)
    RPAREN          reduce using rule 54 (constant -> STRINGVAL .)
    COMMA           reduce using rule 54 (constant -> STRINGVAL .)


state 53

    (55) constant -> CHARVAL .
    OR              reduce using rule 55 (constant -> CHARVAL .)
    AND             reduce using rule 55 (constant -> CHARVAL .)
    RELOP2          reduce using rule 55 (constant -> CHARVAL .)
    RELOP1          reduce using rule 55 (constant -> CHARVAL .)
    MOD             reduce using rule 55 (constant -> CHARVAL .)
    DIVIDE          reduce using rule 55 (constant -> CHARVAL .)
    MULT            reduce using rule 55 (constant -> CHARVAL .)
    MINUS           reduce using rule 55 (constant -> CHARVAL .)
    PLUS            reduce using rule 55 (constant -> CHARVAL .)
    SEMICOL         reduce using rule 55 (constant -> CHARVAL .)
    RPAREN          reduce using rule 55 (constant -> CHARVAL .)
    COMMA           reduce using rule 55 (constant -> CHARVAL .)


state 54

    (56) constant -> FLOATVAL .
    OR              reduce using rule 56 (constant -> FLOATVAL .)
    AND             reduce using rule 56 (constant -> FLOATVAL .)
    RELOP2          reduce using rule 56 (constant -> FLOATVAL .)
    RELOP1          reduce using rule 56 (constant -> FLOATVAL .)
    MOD             reduce using rule 56 (constant -> FLOATVAL .)
    DIVIDE          reduce using rule 56 (constant -> FLOATVAL .)
    MULT            reduce using rule 56 (constant -> FLOATVAL .)
    MINUS           reduce using rule 56 (constant -> FLOATVAL .)
    PLUS            reduce using rule 56 (constant -> FLOATVAL .)
    SEMICOL         reduce using rule 56 (constant -> FLOATVAL .)
    RPAREN          reduce using rule 56 (constant -> FLOATVAL .)
    COMMA           reduce using rule 56 (constant -> FLOATVAL .)


state 55

    (57) constant -> INTVAL .
    OR              reduce using rule 57 (constant -> INTVAL .)
    AND             reduce using rule 57 (constant -> INTVAL .)
    RELOP2          reduce using rule 57 (constant -> INTVAL .)
    RELOP1          reduce using rule 57 (constant -> INTVAL .)
    MOD             reduce using rule 57 (constant -> INTVAL .)
    DIVIDE          reduce using rule 57 (constant -> INTVAL .)
    MULT            reduce using rule 57 (constant -> INTVAL .)
    MINUS           reduce using rule 57 (constant -> INTVAL .)
    PLUS            reduce using rule 57 (constant -> INTVAL .)
    SEMICOL         reduce using rule 57 (constant -> INTVAL .)
    RPAREN          reduce using rule 57 (constant -> INTVAL .)
    COMMA           reduce using rule 57 (constant -> INTVAL .)


state 56

    (16) if_statement -> IF LPAREN expr . RPAREN LBRACE statements RBRACE
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    RPAREN          shift and go to state 76
    OR              shift and go to state 62
    AND             shift and go to state 63
    RELOP2          shift and go to state 64
    RELOP1          shift and go to state 65
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68
    MINUS           shift and go to state 69
    PLUS            shift and go to state 70


state 57

    (20) output_statement -> OUTPUT LPAREN constant . RPAREN
    RPAREN          shift and go to state 77


state 58

    (21) output_statement -> OUTPUT LPAREN left_value . RPAREN
    RPAREN          shift and go to state 78


state 59

    (19) input_statement -> INPUT LPAREN left_value . RPAREN
    RPAREN          shift and go to state 79


state 60

    (44) array_variable -> VARNAME LSQB VARNAME . RSQB LSQB VARNAME RSQB
    (46) array_variable -> VARNAME LSQB VARNAME . RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME LSQB VARNAME . RSQB
    RSQB            shift and go to state 80


state 61

    (45) array_variable -> VARNAME LSQB INTVAL . RSQB LSQB VARNAME RSQB
    (48) array_variable -> VARNAME LSQB INTVAL . RSQB LSQB INTVAL RSQB
    (49) array_variable -> VARNAME LSQB INTVAL . RSQB
    RSQB            shift and go to state 81


state 62

    (31) expr -> expr OR . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 82
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 63

    (32) expr -> expr AND . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 83
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 64

    (33) expr -> expr RELOP2 . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 84
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 65

    (34) expr -> expr RELOP1 . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 85
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 66

    (37) expr -> expr MOD . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 86
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 67

    (38) expr -> expr DIVIDE . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 87
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 68

    (39) expr -> expr MULT . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 88
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 69

    (40) expr -> expr MINUS . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 89
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 70

    (41) expr -> expr PLUS . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 90
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 71

    (27) expr -> LPAREN DATATYPE . RPAREN expr
    RPAREN          shift and go to state 91


state 72

    (35) expr -> LPAREN expr . RPAREN
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    RPAREN          shift and go to state 92
    OR              shift and go to state 62
    AND             shift and go to state 63
    RELOP2          shift and go to state 64
    RELOP1          shift and go to state 65
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68
    MINUS           shift and go to state 69
    PLUS            shift and go to state 70


state 73

    (58) function_call -> VARNAME LPAREN . argument_list RPAREN
    (59) argument_list -> . argument
    (60) argument_list -> . argument COMMA argument_list
    (61) argument -> . array_variable
    (62) argument -> . constant
    (63) argument -> . VARNAME
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB VARNAME RSQB
    (48) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> . VARNAME LSQB INTVAL RSQB
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    VARNAME         shift and go to state 93
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    argument_list                  shift and go to state 94
    argument                       shift and go to state 95
    array_variable                 shift and go to state 96
    constant                       shift and go to state 97

state 74

    (30) expr -> NOT expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 30 (expr -> NOT expr .)
    AND             reduce using rule 30 (expr -> NOT expr .)
    RELOP2          reduce using rule 30 (expr -> NOT expr .)
    RELOP1          reduce using rule 30 (expr -> NOT expr .)
    MOD             reduce using rule 30 (expr -> NOT expr .)
    DIVIDE          reduce using rule 30 (expr -> NOT expr .)
    MULT            reduce using rule 30 (expr -> NOT expr .)
    MINUS           reduce using rule 30 (expr -> NOT expr .)
    PLUS            reduce using rule 30 (expr -> NOT expr .)
    SEMICOL         reduce using rule 30 (expr -> NOT expr .)
    RPAREN          reduce using rule 30 (expr -> NOT expr .)


state 75

    (36) expr -> MINUS expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 36 (expr -> MINUS expr .)
    AND             reduce using rule 36 (expr -> MINUS expr .)
    RELOP2          reduce using rule 36 (expr -> MINUS expr .)
    RELOP1          reduce using rule 36 (expr -> MINUS expr .)
    MOD             reduce using rule 36 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 36 (expr -> MINUS expr .)
    MULT            reduce using rule 36 (expr -> MINUS expr .)
    MINUS           reduce using rule 36 (expr -> MINUS expr .)
    PLUS            reduce using rule 36 (expr -> MINUS expr .)
    SEMICOL         reduce using rule 36 (expr -> MINUS expr .)
    RPAREN          reduce using rule 36 (expr -> MINUS expr .)


state 76

    (16) if_statement -> IF LPAREN expr RPAREN . LBRACE statements RBRACE
    LBRACE          shift and go to state 98


state 77

    (20) output_statement -> OUTPUT LPAREN constant RPAREN .
    SEMICOL         reduce using rule 20 (output_statement -> OUTPUT LPAREN constant RPAREN .)


state 78

    (21) output_statement -> OUTPUT LPAREN left_value RPAREN .
    SEMICOL         reduce using rule 21 (output_statement -> OUTPUT LPAREN left_value RPAREN .)


state 79

    (19) input_statement -> INPUT LPAREN left_value RPAREN .
    SEMICOL         reduce using rule 19 (input_statement -> INPUT LPAREN left_value RPAREN .)


state 80

    (44) array_variable -> VARNAME LSQB VARNAME RSQB . LSQB VARNAME RSQB
    (46) array_variable -> VARNAME LSQB VARNAME RSQB . LSQB INTVAL RSQB
    (47) array_variable -> VARNAME LSQB VARNAME RSQB .
    LSQB            shift and go to state 99
    ASSIGN          reduce using rule 47 (array_variable -> VARNAME LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 47 (array_variable -> VARNAME LSQB VARNAME RSQB .)
    COMMA           reduce using rule 47 (array_variable -> VARNAME LSQB VARNAME RSQB .)


state 81

    (45) array_variable -> VARNAME LSQB INTVAL RSQB . LSQB VARNAME RSQB
    (48) array_variable -> VARNAME LSQB INTVAL RSQB . LSQB INTVAL RSQB
    (49) array_variable -> VARNAME LSQB INTVAL RSQB .
    LSQB            shift and go to state 100
    ASSIGN          reduce using rule 49 (array_variable -> VARNAME LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 49 (array_variable -> VARNAME LSQB INTVAL RSQB .)
    COMMA           reduce using rule 49 (array_variable -> VARNAME LSQB INTVAL RSQB .)


state 82

    (31) expr -> expr OR expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 31 (expr -> expr OR expr .)
    SEMICOL         reduce using rule 31 (expr -> expr OR expr .)
    RPAREN          reduce using rule 31 (expr -> expr OR expr .)
    AND             shift and go to state 63
    RELOP2          shift and go to state 64
    RELOP1          shift and go to state 65
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68
    MINUS           shift and go to state 69
    PLUS            shift and go to state 70


state 83

    (32) expr -> expr AND expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 32 (expr -> expr AND expr .)
    AND             reduce using rule 32 (expr -> expr AND expr .)
    SEMICOL         reduce using rule 32 (expr -> expr AND expr .)
    RPAREN          reduce using rule 32 (expr -> expr AND expr .)
    RELOP2          shift and go to state 64
    RELOP1          shift and go to state 65
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68
    MINUS           shift and go to state 69
    PLUS            shift and go to state 70


state 84

    (33) expr -> expr RELOP2 expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 33 (expr -> expr RELOP2 expr .)
    AND             reduce using rule 33 (expr -> expr RELOP2 expr .)
    RELOP2          reduce using rule 33 (expr -> expr RELOP2 expr .)
    SEMICOL         reduce using rule 33 (expr -> expr RELOP2 expr .)
    RPAREN          reduce using rule 33 (expr -> expr RELOP2 expr .)
    RELOP1          shift and go to state 65
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68
    MINUS           shift and go to state 69
    PLUS            shift and go to state 70


state 85

    (34) expr -> expr RELOP1 expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 34 (expr -> expr RELOP1 expr .)
    AND             reduce using rule 34 (expr -> expr RELOP1 expr .)
    RELOP2          reduce using rule 34 (expr -> expr RELOP1 expr .)
    RELOP1          reduce using rule 34 (expr -> expr RELOP1 expr .)
    SEMICOL         reduce using rule 34 (expr -> expr RELOP1 expr .)
    RPAREN          reduce using rule 34 (expr -> expr RELOP1 expr .)
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68
    MINUS           shift and go to state 69
    PLUS            shift and go to state 70


state 86

    (37) expr -> expr MOD expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 37 (expr -> expr MOD expr .)
    AND             reduce using rule 37 (expr -> expr MOD expr .)
    RELOP2          reduce using rule 37 (expr -> expr MOD expr .)
    RELOP1          reduce using rule 37 (expr -> expr MOD expr .)
    MOD             reduce using rule 37 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 37 (expr -> expr MOD expr .)
    MULT            reduce using rule 37 (expr -> expr MOD expr .)
    MINUS           reduce using rule 37 (expr -> expr MOD expr .)
    PLUS            reduce using rule 37 (expr -> expr MOD expr .)
    SEMICOL         reduce using rule 37 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 37 (expr -> expr MOD expr .)


state 87

    (38) expr -> expr DIVIDE expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 38 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 38 (expr -> expr DIVIDE expr .)
    RELOP2          reduce using rule 38 (expr -> expr DIVIDE expr .)
    RELOP1          reduce using rule 38 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 38 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 38 (expr -> expr DIVIDE expr .)
    MULT            reduce using rule 38 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 38 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 38 (expr -> expr DIVIDE expr .)
    SEMICOL         reduce using rule 38 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 38 (expr -> expr DIVIDE expr .)


state 88

    (39) expr -> expr MULT expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 39 (expr -> expr MULT expr .)
    AND             reduce using rule 39 (expr -> expr MULT expr .)
    RELOP2          reduce using rule 39 (expr -> expr MULT expr .)
    RELOP1          reduce using rule 39 (expr -> expr MULT expr .)
    MOD             reduce using rule 39 (expr -> expr MULT expr .)
    DIVIDE          reduce using rule 39 (expr -> expr MULT expr .)
    MULT            reduce using rule 39 (expr -> expr MULT expr .)
    MINUS           reduce using rule 39 (expr -> expr MULT expr .)
    PLUS            reduce using rule 39 (expr -> expr MULT expr .)
    SEMICOL         reduce using rule 39 (expr -> expr MULT expr .)
    RPAREN          reduce using rule 39 (expr -> expr MULT expr .)


state 89

    (40) expr -> expr MINUS expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 40 (expr -> expr MINUS expr .)
    AND             reduce using rule 40 (expr -> expr MINUS expr .)
    RELOP2          reduce using rule 40 (expr -> expr MINUS expr .)
    RELOP1          reduce using rule 40 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 40 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 40 (expr -> expr MINUS expr .)
    SEMICOL         reduce using rule 40 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 40 (expr -> expr MINUS expr .)
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68


state 90

    (41) expr -> expr PLUS expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 41 (expr -> expr PLUS expr .)
    AND             reduce using rule 41 (expr -> expr PLUS expr .)
    RELOP2          reduce using rule 41 (expr -> expr PLUS expr .)
    RELOP1          reduce using rule 41 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 41 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 41 (expr -> expr PLUS expr .)
    SEMICOL         reduce using rule 41 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 41 (expr -> expr PLUS expr .)
    MOD             shift and go to state 66
    DIVIDE          shift and go to state 67
    MULT            shift and go to state 68


state 91

    (27) expr -> LPAREN DATATYPE RPAREN . expr
    (26) expr -> . function_call
    (27) expr -> . LPAREN DATATYPE RPAREN expr
    (28) expr -> . constant
    (29) expr -> . VARNAME
    (30) expr -> . NOT expr
    (31) expr -> . expr OR expr
    (32) expr -> . expr AND expr
    (33) expr -> . expr RELOP2 expr
    (34) expr -> . expr RELOP1 expr
    (35) expr -> . LPAREN expr RPAREN
    (36) expr -> . MINUS expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr DIVIDE expr
    (39) expr -> . expr MULT expr
    (40) expr -> . expr MINUS expr
    (41) expr -> . expr PLUS expr
    (58) function_call -> . VARNAME LPAREN argument_list RPAREN
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    LPAREN          shift and go to state 46
    VARNAME         shift and go to state 48
    NOT             shift and go to state 49
    MINUS           shift and go to state 50
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    expr                           shift and go to state 101
    function_call                  shift and go to state 45
    constant                       shift and go to state 47

state 92

    (35) expr -> LPAREN expr RPAREN .
    OR              reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    RELOP2          reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    RELOP1          reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    SEMICOL         reduce using rule 35 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 35 (expr -> LPAREN expr RPAREN .)


state 93

    (63) argument -> VARNAME .
    (44) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME . LSQB VARNAME RSQB
    (48) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> VARNAME . LSQB INTVAL RSQB
    COMMA           reduce using rule 63 (argument -> VARNAME .)
    RPAREN          reduce using rule 63 (argument -> VARNAME .)
    LSQB            shift and go to state 43


state 94

    (58) function_call -> VARNAME LPAREN argument_list . RPAREN
    RPAREN          shift and go to state 102


state 95

    (59) argument_list -> argument .
    (60) argument_list -> argument . COMMA argument_list
    RPAREN          reduce using rule 59 (argument_list -> argument .)
    COMMA           shift and go to state 103


state 96

    (61) argument -> array_variable .
    COMMA           reduce using rule 61 (argument -> array_variable .)
    RPAREN          reduce using rule 61 (argument -> array_variable .)


state 97

    (62) argument -> constant .
    COMMA           reduce using rule 62 (argument -> constant .)
    RPAREN          reduce using rule 62 (argument -> constant .)


state 98

    (16) if_statement -> IF LPAREN expr RPAREN LBRACE . statements RBRACE
    (7) statements -> . empty
    (8) statements -> . statements statement
    (64) empty -> .
    RBRACE          reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    OUTPUT          reduce using rule 64 (empty -> .)
    INPUT           reduce using rule 64 (empty -> .)
    VARNAME         reduce using rule 64 (empty -> .)
    DATATYPE        reduce using rule 64 (empty -> .)

    statements                     shift and go to state 104
    empty                          shift and go to state 17

state 99

    (44) array_variable -> VARNAME LSQB VARNAME RSQB LSQB . VARNAME RSQB
    (46) array_variable -> VARNAME LSQB VARNAME RSQB LSQB . INTVAL RSQB
    VARNAME         shift and go to state 105
    INTVAL          shift and go to state 106


state 100

    (45) array_variable -> VARNAME LSQB INTVAL RSQB LSQB . VARNAME RSQB
    (48) array_variable -> VARNAME LSQB INTVAL RSQB LSQB . INTVAL RSQB
    VARNAME         shift and go to state 107
    INTVAL          shift and go to state 108


state 101

    (27) expr -> LPAREN DATATYPE RPAREN expr .
    (31) expr -> expr . OR expr
    (32) expr -> expr . AND expr
    (33) expr -> expr . RELOP2 expr
    (34) expr -> expr . RELOP1 expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . DIVIDE expr
    (39) expr -> expr . MULT expr
    (40) expr -> expr . MINUS expr
    (41) expr -> expr . PLUS expr
    OR              reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    AND             reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    RELOP2          reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    RELOP1          reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    MOD             reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    DIVIDE          reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    MULT            reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    MINUS           reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    PLUS            reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    SEMICOL         reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)
    RPAREN          reduce using rule 27 (expr -> LPAREN DATATYPE RPAREN expr .)


state 102

    (58) function_call -> VARNAME LPAREN argument_list RPAREN .
    OR              reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    AND             reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RELOP2          reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RELOP1          reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MOD             reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MULT            reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    SEMICOL         reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 58 (function_call -> VARNAME LPAREN argument_list RPAREN .)


state 103

    (60) argument_list -> argument COMMA . argument_list
    (59) argument_list -> . argument
    (60) argument_list -> . argument COMMA argument_list
    (61) argument -> . array_variable
    (62) argument -> . constant
    (63) argument -> . VARNAME
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB VARNAME RSQB
    (48) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> . VARNAME LSQB INTVAL RSQB
    (53) constant -> . BOOLVAL
    (54) constant -> . STRINGVAL
    (55) constant -> . CHARVAL
    (56) constant -> . FLOATVAL
    (57) constant -> . INTVAL
    VARNAME         shift and go to state 93
    BOOLVAL         shift and go to state 51
    STRINGVAL       shift and go to state 52
    CHARVAL         shift and go to state 53
    FLOATVAL        shift and go to state 54
    INTVAL          shift and go to state 55

    argument                       shift and go to state 95
    argument_list                  shift and go to state 109
    array_variable                 shift and go to state 96
    constant                       shift and go to state 97

state 104

    (16) if_statement -> IF LPAREN expr RPAREN LBRACE statements . RBRACE
    (8) statements -> statements . statement
    (9) statement -> . selection_statement
    (10) statement -> . io_statement SEMICOL
    (11) statement -> . assignment_statement SEMICOL
    (12) statement -> . declaration_statement SEMICOL
    (13) selection_statement -> . if_statement
    (17) io_statement -> . output_statement
    (18) io_statement -> . input_statement
    (50) assignment_statement -> . left_value ASSIGN expr
    (14) declaration_statement -> . simple_init
    (16) if_statement -> . IF LPAREN expr RPAREN LBRACE statements RBRACE
    (20) output_statement -> . OUTPUT LPAREN constant RPAREN
    (21) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (19) input_statement -> . INPUT LPAREN left_value RPAREN
    (51) left_value -> . array_variable
    (52) left_value -> . VARNAME
    (15) simple_init -> . DATATYPE VARNAME
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (45) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB VARNAME RSQB
    (48) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (49) array_variable -> . VARNAME LSQB INTVAL RSQB
    RBRACE          shift and go to state 110
    IF              shift and go to state 30
    OUTPUT          shift and go to state 31
    INPUT           shift and go to state 32
    VARNAME         shift and go to state 34
    DATATYPE        shift and go to state 18

    statement                      shift and go to state 20
    selection_statement            shift and go to state 21
    io_statement                   shift and go to state 22
    assignment_statement           shift and go to state 23
    declaration_statement          shift and go to state 24
    if_statement                   shift and go to state 25
    output_statement               shift and go to state 26
    input_statement                shift and go to state 27
    left_value                     shift and go to state 28
    simple_init                    shift and go to state 29
    array_variable                 shift and go to state 33

state 105

    (44) array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME . RSQB
    RSQB            shift and go to state 111


state 106

    (46) array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL . RSQB
    RSQB            shift and go to state 112


state 107

    (45) array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME . RSQB
    RSQB            shift and go to state 113


state 108

    (48) array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL . RSQB
    RSQB            shift and go to state 114


state 109

    (60) argument_list -> argument COMMA argument_list .
    RPAREN          reduce using rule 60 (argument_list -> argument COMMA argument_list .)


state 110

    (16) if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE .
    RBRACE          reduce using rule 16 (if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 16 (if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE .)
    OUTPUT          reduce using rule 16 (if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE .)
    INPUT           reduce using rule 16 (if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE .)
    VARNAME         reduce using rule 16 (if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE .)
    DATATYPE        reduce using rule 16 (if_statement -> IF LPAREN expr RPAREN LBRACE statements RBRACE .)


state 111

    (44) array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .
    ASSIGN          reduce using rule 44 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 44 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)
    COMMA           reduce using rule 44 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)


state 112

    (46) array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .
    ASSIGN          reduce using rule 46 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 46 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)
    COMMA           reduce using rule 46 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)


state 113

    (45) array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .
    ASSIGN          reduce using rule 45 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 45 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)
    COMMA           reduce using rule 45 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)


state 114

    (48) array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .
    ASSIGN          reduce using rule 48 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 48 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)
    COMMA           reduce using rule 48 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)
