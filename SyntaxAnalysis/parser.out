Grammar:

Rule 0     S' -> statements
Rule 1     statements -> <empty>
Rule 2     statements -> statement statements
Rule 3     statement -> if_statement
Rule 4     statement -> io_statement SEMICOL
Rule 5     statement -> assignment_statement SEMICOL
Rule 6     statement -> declaration_statement SEMICOL
Rule 7     declaration_statement -> simple_init
Rule 8     simple_init -> DATATYPE VARNAME
Rule 9     if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE
Rule 10    if_open -> <empty>
Rule 11    if_close -> <empty>
Rule 12    io_statement -> output_statement
Rule 13    io_statement -> input_statement
Rule 14    input_statement -> INPUT LPAREN left_value RPAREN
Rule 15    output_statement -> OUTPUT LPAREN constant RPAREN
Rule 16    output_statement -> OUTPUT LPAREN left_value RPAREN
Rule 17    jump_statement -> return_statement
Rule 18    jump_statement -> BREAK
Rule 19    return_statement -> RETURN
Rule 20    return_statement -> RETURN expr
Rule 21    expr -> function_call
Rule 22    expr -> LPAREN DATATYPE RPAREN expr  [precedence=right, level=9]
Rule 23    expr -> constant
Rule 24    expr -> VARNAME
Rule 25    expr -> NOT expr  [precedence=right, level=10]
Rule 26    expr -> expr OR expr  [precedence=left, level=3]
Rule 27    expr -> expr AND expr  [precedence=left, level=4]
Rule 28    expr -> expr RELOP2 expr  [precedence=left, level=5]
Rule 29    expr -> expr RELOP1 expr  [precedence=left, level=6]
Rule 30    expr -> LPAREN expr RPAREN  [precedence=right, level=11]
Rule 31    expr -> MINUS expr  [precedence=right, level=10]
Rule 32    expr -> expr MOD expr  [precedence=left, level=8]
Rule 33    expr -> expr DIVIDE expr  [precedence=left, level=8]
Rule 34    expr -> expr MULT expr  [precedence=left, level=8]
Rule 35    expr -> expr MINUS expr  [precedence=left, level=7]
Rule 36    expr -> expr PLUS expr  [precedence=left, level=7]
Rule 37    array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
Rule 38    array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
Rule 39    array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
Rule 40    array_variable -> VARNAME LSQB VARNAME RSQB
Rule 41    array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
Rule 42    array_variable -> VARNAME LSQB INTVAL RSQB
Rule 43    assignment_statement -> left_value ASSIGN expr  [precedence=right, level=2]
Rule 44    left_value -> array_variable
Rule 45    left_value -> VARNAME
Rule 46    constant -> BOOLVAL
Rule 47    constant -> STRINGVAL
Rule 48    constant -> CHARVAL
Rule 49    constant -> FLOATVAL
Rule 50    constant -> INTVAL
Rule 51    function_call -> VARNAME LPAREN argument_list RPAREN
Rule 52    argument_list -> argument
Rule 53    argument_list -> argument COMMA argument_list  [precedence=left, level=1]
Rule 54    argument -> array_variable
Rule 55    argument -> constant
Rule 56    argument -> VARNAME

Unused terminals:

    FUNCNAME
    COLON
    FUZZY
    ELSE
    CASE
    FOR
    ELIF
    DEFAULT
    SWITCH
    WHILE

Terminals, with rules where they appear:

AND                  : 27
ASSIGN               : 43
BOOLVAL              : 46
BREAK                : 18
CASE                 : 
CHARVAL              : 48
COLON                : 
COMMA                : 53
DATATYPE             : 8 22
DEFAULT              : 
DIVIDE               : 33
ELIF                 : 
ELSE                 : 
FLOATVAL             : 49
FOR                  : 
FUNCNAME             : 
FUZZY                : 
IF                   : 9
INPUT                : 14
INTVAL               : 38 39 41 41 42 50
LBRACE               : 9
LPAREN               : 9 14 15 16 22 30 51
LSQB                 : 37 37 38 38 39 39 40 41 41 42
MINUS                : 31 35
MOD                  : 32
MULT                 : 34
NOT                  : 25
OR                   : 26
OUTPUT               : 15 16
PLUS                 : 36
RBRACE               : 9
RELOP1               : 29
RELOP2               : 28
RETURN               : 19 20
RPAREN               : 9 14 15 16 22 30 51
RSQB                 : 37 37 38 38 39 39 40 41 41 42
SEMICOL              : 4 5 6
STRINGVAL            : 47
SWITCH               : 
VARNAME              : 8 24 37 37 37 38 38 39 39 40 40 41 42 45 51 56
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

argument             : 52 53
argument_list        : 51 53
array_variable       : 44 54
assignment_statement : 5
constant             : 15 23 55
declaration_statement : 6
expr                 : 9 20 22 25 26 26 27 27 28 28 29 29 30 31 32 32 33 33 34 34 35 35 36 36 43
function_call        : 21
if_close             : 9
if_open              : 9
if_statement         : 3
input_statement      : 13
io_statement         : 4
jump_statement       : 
left_value           : 14 16 43
output_statement     : 12
return_statement     : 17
simple_init          : 7
statement            : 2
statements           : 2 9 0


state 0

    (0) S' -> . statements
    (1) statements -> .
    (2) statements -> . statement statements
    (3) statement -> . if_statement
    (4) statement -> . io_statement SEMICOL
    (5) statement -> . assignment_statement SEMICOL
    (6) statement -> . declaration_statement SEMICOL
    (9) if_statement -> . IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE
    (12) io_statement -> . output_statement
    (13) io_statement -> . input_statement
    (43) assignment_statement -> . left_value ASSIGN expr
    (7) declaration_statement -> . simple_init
    (15) output_statement -> . OUTPUT LPAREN constant RPAREN
    (16) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (14) input_statement -> . INPUT LPAREN left_value RPAREN
    (44) left_value -> . array_variable
    (45) left_value -> . VARNAME
    (8) simple_init -> . DATATYPE VARNAME
    (37) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> . VARNAME LSQB VARNAME RSQB
    (41) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> . VARNAME LSQB INTVAL RSQB
    $end            reduce using rule 1 (statements -> .)
    IF              shift and go to state 7
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    VARNAME         shift and go to state 15
    DATATYPE        shift and go to state 16

    statements                     shift and go to state 1
    statement                      shift and go to state 2
    if_statement                   shift and go to state 3
    io_statement                   shift and go to state 4
    assignment_statement           shift and go to state 5
    declaration_statement          shift and go to state 6
    output_statement               shift and go to state 8
    input_statement                shift and go to state 9
    left_value                     shift and go to state 10
    simple_init                    shift and go to state 11
    array_variable                 shift and go to state 14

state 1

    (0) S' -> statements .


state 2

    (2) statements -> statement . statements
    (1) statements -> .
    (2) statements -> . statement statements
    (3) statement -> . if_statement
    (4) statement -> . io_statement SEMICOL
    (5) statement -> . assignment_statement SEMICOL
    (6) statement -> . declaration_statement SEMICOL
    (9) if_statement -> . IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE
    (12) io_statement -> . output_statement
    (13) io_statement -> . input_statement
    (43) assignment_statement -> . left_value ASSIGN expr
    (7) declaration_statement -> . simple_init
    (15) output_statement -> . OUTPUT LPAREN constant RPAREN
    (16) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (14) input_statement -> . INPUT LPAREN left_value RPAREN
    (44) left_value -> . array_variable
    (45) left_value -> . VARNAME
    (8) simple_init -> . DATATYPE VARNAME
    (37) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> . VARNAME LSQB VARNAME RSQB
    (41) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> . VARNAME LSQB INTVAL RSQB
    $end            reduce using rule 1 (statements -> .)
    RBRACE          reduce using rule 1 (statements -> .)
    IF              shift and go to state 7
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    VARNAME         shift and go to state 15
    DATATYPE        shift and go to state 16

    statement                      shift and go to state 2
    statements                     shift and go to state 17
    if_statement                   shift and go to state 3
    io_statement                   shift and go to state 4
    assignment_statement           shift and go to state 5
    declaration_statement          shift and go to state 6
    output_statement               shift and go to state 8
    input_statement                shift and go to state 9
    left_value                     shift and go to state 10
    simple_init                    shift and go to state 11
    array_variable                 shift and go to state 14

state 3

    (3) statement -> if_statement .
    IF              reduce using rule 3 (statement -> if_statement .)
    OUTPUT          reduce using rule 3 (statement -> if_statement .)
    INPUT           reduce using rule 3 (statement -> if_statement .)
    VARNAME         reduce using rule 3 (statement -> if_statement .)
    DATATYPE        reduce using rule 3 (statement -> if_statement .)
    $end            reduce using rule 3 (statement -> if_statement .)
    RBRACE          reduce using rule 3 (statement -> if_statement .)


state 4

    (4) statement -> io_statement . SEMICOL
    SEMICOL         shift and go to state 18


state 5

    (5) statement -> assignment_statement . SEMICOL
    SEMICOL         shift and go to state 19


state 6

    (6) statement -> declaration_statement . SEMICOL
    SEMICOL         shift and go to state 20


state 7

    (9) if_statement -> IF . LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE
    LPAREN          shift and go to state 21


state 8

    (12) io_statement -> output_statement .
    SEMICOL         reduce using rule 12 (io_statement -> output_statement .)


state 9

    (13) io_statement -> input_statement .
    SEMICOL         reduce using rule 13 (io_statement -> input_statement .)


state 10

    (43) assignment_statement -> left_value . ASSIGN expr
    ASSIGN          shift and go to state 22


state 11

    (7) declaration_statement -> simple_init .
    SEMICOL         reduce using rule 7 (declaration_statement -> simple_init .)


state 12

    (15) output_statement -> OUTPUT . LPAREN constant RPAREN
    (16) output_statement -> OUTPUT . LPAREN left_value RPAREN
    LPAREN          shift and go to state 23


state 13

    (14) input_statement -> INPUT . LPAREN left_value RPAREN
    LPAREN          shift and go to state 24


state 14

    (44) left_value -> array_variable .
    ASSIGN          reduce using rule 44 (left_value -> array_variable .)
    RPAREN          reduce using rule 44 (left_value -> array_variable .)


state 15

    (45) left_value -> VARNAME .
    (37) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> VARNAME . LSQB VARNAME RSQB
    (41) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> VARNAME . LSQB INTVAL RSQB
    ASSIGN          reduce using rule 45 (left_value -> VARNAME .)
    RPAREN          reduce using rule 45 (left_value -> VARNAME .)
    LSQB            shift and go to state 25


state 16

    (8) simple_init -> DATATYPE . VARNAME
    VARNAME         shift and go to state 26


state 17

    (2) statements -> statement statements .
    $end            reduce using rule 2 (statements -> statement statements .)
    RBRACE          reduce using rule 2 (statements -> statement statements .)


state 18

    (4) statement -> io_statement SEMICOL .
    IF              reduce using rule 4 (statement -> io_statement SEMICOL .)
    OUTPUT          reduce using rule 4 (statement -> io_statement SEMICOL .)
    INPUT           reduce using rule 4 (statement -> io_statement SEMICOL .)
    VARNAME         reduce using rule 4 (statement -> io_statement SEMICOL .)
    DATATYPE        reduce using rule 4 (statement -> io_statement SEMICOL .)
    $end            reduce using rule 4 (statement -> io_statement SEMICOL .)
    RBRACE          reduce using rule 4 (statement -> io_statement SEMICOL .)


state 19

    (5) statement -> assignment_statement SEMICOL .
    IF              reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    OUTPUT          reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    INPUT           reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    VARNAME         reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    DATATYPE        reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    $end            reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    RBRACE          reduce using rule 5 (statement -> assignment_statement SEMICOL .)


state 20

    (6) statement -> declaration_statement SEMICOL .
    IF              reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    OUTPUT          reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    INPUT           reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    VARNAME         reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    DATATYPE        reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    $end            reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    RBRACE          reduce using rule 6 (statement -> declaration_statement SEMICOL .)


state 21

    (9) if_statement -> IF LPAREN . expr RPAREN LBRACE if_open statements if_close RBRACE
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 28
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 22

    (43) assignment_statement -> left_value ASSIGN . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 39
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 23

    (15) output_statement -> OUTPUT LPAREN . constant RPAREN
    (16) output_statement -> OUTPUT LPAREN . left_value RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    (44) left_value -> . array_variable
    (45) left_value -> . VARNAME
    (37) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> . VARNAME LSQB VARNAME RSQB
    (41) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> . VARNAME LSQB INTVAL RSQB
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38
    VARNAME         shift and go to state 15

    constant                       shift and go to state 40
    left_value                     shift and go to state 41
    array_variable                 shift and go to state 14

state 24

    (14) input_statement -> INPUT LPAREN . left_value RPAREN
    (44) left_value -> . array_variable
    (45) left_value -> . VARNAME
    (37) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> . VARNAME LSQB VARNAME RSQB
    (41) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> . VARNAME LSQB INTVAL RSQB
    VARNAME         shift and go to state 15

    left_value                     shift and go to state 42
    array_variable                 shift and go to state 14

state 25

    (37) array_variable -> VARNAME LSQB . VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> VARNAME LSQB . INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> VARNAME LSQB . VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> VARNAME LSQB . VARNAME RSQB
    (41) array_variable -> VARNAME LSQB . INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> VARNAME LSQB . INTVAL RSQB
    VARNAME         shift and go to state 43
    INTVAL          shift and go to state 44


state 26

    (8) simple_init -> DATATYPE VARNAME .
    SEMICOL         reduce using rule 8 (simple_init -> DATATYPE VARNAME .)


state 27

    (22) expr -> LPAREN . DATATYPE RPAREN expr
    (30) expr -> LPAREN . expr RPAREN
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    DATATYPE        shift and go to state 45
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 46
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 28

    (9) if_statement -> IF LPAREN expr . RPAREN LBRACE if_open statements if_close RBRACE
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          shift and go to state 47
    OR              shift and go to state 48
    AND             shift and go to state 49
    RELOP2          shift and go to state 50
    RELOP1          shift and go to state 51
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54
    MINUS           shift and go to state 55
    PLUS            shift and go to state 56


state 29

    (21) expr -> function_call .
    RPAREN          reduce using rule 21 (expr -> function_call .)
    OR              reduce using rule 21 (expr -> function_call .)
    AND             reduce using rule 21 (expr -> function_call .)
    RELOP2          reduce using rule 21 (expr -> function_call .)
    RELOP1          reduce using rule 21 (expr -> function_call .)
    MOD             reduce using rule 21 (expr -> function_call .)
    DIVIDE          reduce using rule 21 (expr -> function_call .)
    MULT            reduce using rule 21 (expr -> function_call .)
    MINUS           reduce using rule 21 (expr -> function_call .)
    PLUS            reduce using rule 21 (expr -> function_call .)
    SEMICOL         reduce using rule 21 (expr -> function_call .)


state 30

    (23) expr -> constant .
    RPAREN          reduce using rule 23 (expr -> constant .)
    OR              reduce using rule 23 (expr -> constant .)
    AND             reduce using rule 23 (expr -> constant .)
    RELOP2          reduce using rule 23 (expr -> constant .)
    RELOP1          reduce using rule 23 (expr -> constant .)
    MOD             reduce using rule 23 (expr -> constant .)
    DIVIDE          reduce using rule 23 (expr -> constant .)
    MULT            reduce using rule 23 (expr -> constant .)
    MINUS           reduce using rule 23 (expr -> constant .)
    PLUS            reduce using rule 23 (expr -> constant .)
    SEMICOL         reduce using rule 23 (expr -> constant .)


state 31

    (24) expr -> VARNAME .
    (51) function_call -> VARNAME . LPAREN argument_list RPAREN
    RPAREN          reduce using rule 24 (expr -> VARNAME .)
    OR              reduce using rule 24 (expr -> VARNAME .)
    AND             reduce using rule 24 (expr -> VARNAME .)
    RELOP2          reduce using rule 24 (expr -> VARNAME .)
    RELOP1          reduce using rule 24 (expr -> VARNAME .)
    MOD             reduce using rule 24 (expr -> VARNAME .)
    DIVIDE          reduce using rule 24 (expr -> VARNAME .)
    MULT            reduce using rule 24 (expr -> VARNAME .)
    MINUS           reduce using rule 24 (expr -> VARNAME .)
    PLUS            reduce using rule 24 (expr -> VARNAME .)
    SEMICOL         reduce using rule 24 (expr -> VARNAME .)
    LPAREN          shift and go to state 57


state 32

    (25) expr -> NOT . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 58
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 33

    (31) expr -> MINUS . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 59
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 34

    (46) constant -> BOOLVAL .
    RPAREN          reduce using rule 46 (constant -> BOOLVAL .)
    OR              reduce using rule 46 (constant -> BOOLVAL .)
    AND             reduce using rule 46 (constant -> BOOLVAL .)
    RELOP2          reduce using rule 46 (constant -> BOOLVAL .)
    RELOP1          reduce using rule 46 (constant -> BOOLVAL .)
    MOD             reduce using rule 46 (constant -> BOOLVAL .)
    DIVIDE          reduce using rule 46 (constant -> BOOLVAL .)
    MULT            reduce using rule 46 (constant -> BOOLVAL .)
    MINUS           reduce using rule 46 (constant -> BOOLVAL .)
    PLUS            reduce using rule 46 (constant -> BOOLVAL .)
    SEMICOL         reduce using rule 46 (constant -> BOOLVAL .)
    COMMA           reduce using rule 46 (constant -> BOOLVAL .)


state 35

    (47) constant -> STRINGVAL .
    RPAREN          reduce using rule 47 (constant -> STRINGVAL .)
    OR              reduce using rule 47 (constant -> STRINGVAL .)
    AND             reduce using rule 47 (constant -> STRINGVAL .)
    RELOP2          reduce using rule 47 (constant -> STRINGVAL .)
    RELOP1          reduce using rule 47 (constant -> STRINGVAL .)
    MOD             reduce using rule 47 (constant -> STRINGVAL .)
    DIVIDE          reduce using rule 47 (constant -> STRINGVAL .)
    MULT            reduce using rule 47 (constant -> STRINGVAL .)
    MINUS           reduce using rule 47 (constant -> STRINGVAL .)
    PLUS            reduce using rule 47 (constant -> STRINGVAL .)
    SEMICOL         reduce using rule 47 (constant -> STRINGVAL .)
    COMMA           reduce using rule 47 (constant -> STRINGVAL .)


state 36

    (48) constant -> CHARVAL .
    RPAREN          reduce using rule 48 (constant -> CHARVAL .)
    OR              reduce using rule 48 (constant -> CHARVAL .)
    AND             reduce using rule 48 (constant -> CHARVAL .)
    RELOP2          reduce using rule 48 (constant -> CHARVAL .)
    RELOP1          reduce using rule 48 (constant -> CHARVAL .)
    MOD             reduce using rule 48 (constant -> CHARVAL .)
    DIVIDE          reduce using rule 48 (constant -> CHARVAL .)
    MULT            reduce using rule 48 (constant -> CHARVAL .)
    MINUS           reduce using rule 48 (constant -> CHARVAL .)
    PLUS            reduce using rule 48 (constant -> CHARVAL .)
    SEMICOL         reduce using rule 48 (constant -> CHARVAL .)
    COMMA           reduce using rule 48 (constant -> CHARVAL .)


state 37

    (49) constant -> FLOATVAL .
    RPAREN          reduce using rule 49 (constant -> FLOATVAL .)
    OR              reduce using rule 49 (constant -> FLOATVAL .)
    AND             reduce using rule 49 (constant -> FLOATVAL .)
    RELOP2          reduce using rule 49 (constant -> FLOATVAL .)
    RELOP1          reduce using rule 49 (constant -> FLOATVAL .)
    MOD             reduce using rule 49 (constant -> FLOATVAL .)
    DIVIDE          reduce using rule 49 (constant -> FLOATVAL .)
    MULT            reduce using rule 49 (constant -> FLOATVAL .)
    MINUS           reduce using rule 49 (constant -> FLOATVAL .)
    PLUS            reduce using rule 49 (constant -> FLOATVAL .)
    SEMICOL         reduce using rule 49 (constant -> FLOATVAL .)
    COMMA           reduce using rule 49 (constant -> FLOATVAL .)


state 38

    (50) constant -> INTVAL .
    RPAREN          reduce using rule 50 (constant -> INTVAL .)
    OR              reduce using rule 50 (constant -> INTVAL .)
    AND             reduce using rule 50 (constant -> INTVAL .)
    RELOP2          reduce using rule 50 (constant -> INTVAL .)
    RELOP1          reduce using rule 50 (constant -> INTVAL .)
    MOD             reduce using rule 50 (constant -> INTVAL .)
    DIVIDE          reduce using rule 50 (constant -> INTVAL .)
    MULT            reduce using rule 50 (constant -> INTVAL .)
    MINUS           reduce using rule 50 (constant -> INTVAL .)
    PLUS            reduce using rule 50 (constant -> INTVAL .)
    SEMICOL         reduce using rule 50 (constant -> INTVAL .)
    COMMA           reduce using rule 50 (constant -> INTVAL .)


state 39

    (43) assignment_statement -> left_value ASSIGN expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    SEMICOL         reduce using rule 43 (assignment_statement -> left_value ASSIGN expr .)
    OR              shift and go to state 48
    AND             shift and go to state 49
    RELOP2          shift and go to state 50
    RELOP1          shift and go to state 51
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54
    MINUS           shift and go to state 55
    PLUS            shift and go to state 56


state 40

    (15) output_statement -> OUTPUT LPAREN constant . RPAREN
    RPAREN          shift and go to state 60


state 41

    (16) output_statement -> OUTPUT LPAREN left_value . RPAREN
    RPAREN          shift and go to state 61


state 42

    (14) input_statement -> INPUT LPAREN left_value . RPAREN
    RPAREN          shift and go to state 62


state 43

    (37) array_variable -> VARNAME LSQB VARNAME . RSQB LSQB VARNAME RSQB
    (39) array_variable -> VARNAME LSQB VARNAME . RSQB LSQB INTVAL RSQB
    (40) array_variable -> VARNAME LSQB VARNAME . RSQB
    RSQB            shift and go to state 63


state 44

    (38) array_variable -> VARNAME LSQB INTVAL . RSQB LSQB VARNAME RSQB
    (41) array_variable -> VARNAME LSQB INTVAL . RSQB LSQB INTVAL RSQB
    (42) array_variable -> VARNAME LSQB INTVAL . RSQB
    RSQB            shift and go to state 64


state 45

    (22) expr -> LPAREN DATATYPE . RPAREN expr
    RPAREN          shift and go to state 65


state 46

    (30) expr -> LPAREN expr . RPAREN
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          shift and go to state 66
    OR              shift and go to state 48
    AND             shift and go to state 49
    RELOP2          shift and go to state 50
    RELOP1          shift and go to state 51
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54
    MINUS           shift and go to state 55
    PLUS            shift and go to state 56


state 47

    (9) if_statement -> IF LPAREN expr RPAREN . LBRACE if_open statements if_close RBRACE
    LBRACE          shift and go to state 67


state 48

    (26) expr -> expr OR . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 68
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 49

    (27) expr -> expr AND . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 69
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 50

    (28) expr -> expr RELOP2 . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 70
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 51

    (29) expr -> expr RELOP1 . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 71
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 52

    (32) expr -> expr MOD . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 72
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 53

    (33) expr -> expr DIVIDE . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 73
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 54

    (34) expr -> expr MULT . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 74
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 55

    (35) expr -> expr MINUS . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 75
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 56

    (36) expr -> expr PLUS . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 76
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 57

    (51) function_call -> VARNAME LPAREN . argument_list RPAREN
    (52) argument_list -> . argument
    (53) argument_list -> . argument COMMA argument_list
    (54) argument -> . array_variable
    (55) argument -> . constant
    (56) argument -> . VARNAME
    (37) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> . VARNAME LSQB VARNAME RSQB
    (41) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> . VARNAME LSQB INTVAL RSQB
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    VARNAME         shift and go to state 77
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    argument_list                  shift and go to state 78
    argument                       shift and go to state 79
    array_variable                 shift and go to state 80
    constant                       shift and go to state 81

state 58

    (25) expr -> NOT expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 25 (expr -> NOT expr .)
    OR              reduce using rule 25 (expr -> NOT expr .)
    AND             reduce using rule 25 (expr -> NOT expr .)
    RELOP2          reduce using rule 25 (expr -> NOT expr .)
    RELOP1          reduce using rule 25 (expr -> NOT expr .)
    MOD             reduce using rule 25 (expr -> NOT expr .)
    DIVIDE          reduce using rule 25 (expr -> NOT expr .)
    MULT            reduce using rule 25 (expr -> NOT expr .)
    MINUS           reduce using rule 25 (expr -> NOT expr .)
    PLUS            reduce using rule 25 (expr -> NOT expr .)
    SEMICOL         reduce using rule 25 (expr -> NOT expr .)


state 59

    (31) expr -> MINUS expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 31 (expr -> MINUS expr .)
    OR              reduce using rule 31 (expr -> MINUS expr .)
    AND             reduce using rule 31 (expr -> MINUS expr .)
    RELOP2          reduce using rule 31 (expr -> MINUS expr .)
    RELOP1          reduce using rule 31 (expr -> MINUS expr .)
    MOD             reduce using rule 31 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 31 (expr -> MINUS expr .)
    MULT            reduce using rule 31 (expr -> MINUS expr .)
    MINUS           reduce using rule 31 (expr -> MINUS expr .)
    PLUS            reduce using rule 31 (expr -> MINUS expr .)
    SEMICOL         reduce using rule 31 (expr -> MINUS expr .)


state 60

    (15) output_statement -> OUTPUT LPAREN constant RPAREN .
    SEMICOL         reduce using rule 15 (output_statement -> OUTPUT LPAREN constant RPAREN .)


state 61

    (16) output_statement -> OUTPUT LPAREN left_value RPAREN .
    SEMICOL         reduce using rule 16 (output_statement -> OUTPUT LPAREN left_value RPAREN .)


state 62

    (14) input_statement -> INPUT LPAREN left_value RPAREN .
    SEMICOL         reduce using rule 14 (input_statement -> INPUT LPAREN left_value RPAREN .)


state 63

    (37) array_variable -> VARNAME LSQB VARNAME RSQB . LSQB VARNAME RSQB
    (39) array_variable -> VARNAME LSQB VARNAME RSQB . LSQB INTVAL RSQB
    (40) array_variable -> VARNAME LSQB VARNAME RSQB .
    LSQB            shift and go to state 82
    ASSIGN          reduce using rule 40 (array_variable -> VARNAME LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 40 (array_variable -> VARNAME LSQB VARNAME RSQB .)
    COMMA           reduce using rule 40 (array_variable -> VARNAME LSQB VARNAME RSQB .)


state 64

    (38) array_variable -> VARNAME LSQB INTVAL RSQB . LSQB VARNAME RSQB
    (41) array_variable -> VARNAME LSQB INTVAL RSQB . LSQB INTVAL RSQB
    (42) array_variable -> VARNAME LSQB INTVAL RSQB .
    LSQB            shift and go to state 83
    ASSIGN          reduce using rule 42 (array_variable -> VARNAME LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 42 (array_variable -> VARNAME LSQB INTVAL RSQB .)
    COMMA           reduce using rule 42 (array_variable -> VARNAME LSQB INTVAL RSQB .)


state 65

    (22) expr -> LPAREN DATATYPE RPAREN . expr
    (21) expr -> . function_call
    (22) expr -> . LPAREN DATATYPE RPAREN expr
    (23) expr -> . constant
    (24) expr -> . VARNAME
    (25) expr -> . NOT expr
    (26) expr -> . expr OR expr
    (27) expr -> . expr AND expr
    (28) expr -> . expr RELOP2 expr
    (29) expr -> . expr RELOP1 expr
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . MINUS expr
    (32) expr -> . expr MOD expr
    (33) expr -> . expr DIVIDE expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr PLUS expr
    (51) function_call -> . VARNAME LPAREN argument_list RPAREN
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    LPAREN          shift and go to state 27
    VARNAME         shift and go to state 31
    NOT             shift and go to state 32
    MINUS           shift and go to state 33
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    expr                           shift and go to state 84
    function_call                  shift and go to state 29
    constant                       shift and go to state 30

state 66

    (30) expr -> LPAREN expr RPAREN .
    RPAREN          reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    RELOP2          reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    RELOP1          reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    SEMICOL         reduce using rule 30 (expr -> LPAREN expr RPAREN .)


state 67

    (9) if_statement -> IF LPAREN expr RPAREN LBRACE . if_open statements if_close RBRACE
    (10) if_open -> .
    IF              reduce using rule 10 (if_open -> .)
    OUTPUT          reduce using rule 10 (if_open -> .)
    INPUT           reduce using rule 10 (if_open -> .)
    VARNAME         reduce using rule 10 (if_open -> .)
    DATATYPE        reduce using rule 10 (if_open -> .)
    RBRACE          reduce using rule 10 (if_open -> .)

    if_open                        shift and go to state 85

state 68

    (26) expr -> expr OR expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 26 (expr -> expr OR expr .)
    OR              reduce using rule 26 (expr -> expr OR expr .)
    SEMICOL         reduce using rule 26 (expr -> expr OR expr .)
    AND             shift and go to state 49
    RELOP2          shift and go to state 50
    RELOP1          shift and go to state 51
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54
    MINUS           shift and go to state 55
    PLUS            shift and go to state 56


state 69

    (27) expr -> expr AND expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 27 (expr -> expr AND expr .)
    OR              reduce using rule 27 (expr -> expr AND expr .)
    AND             reduce using rule 27 (expr -> expr AND expr .)
    SEMICOL         reduce using rule 27 (expr -> expr AND expr .)
    RELOP2          shift and go to state 50
    RELOP1          shift and go to state 51
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54
    MINUS           shift and go to state 55
    PLUS            shift and go to state 56


state 70

    (28) expr -> expr RELOP2 expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 28 (expr -> expr RELOP2 expr .)
    OR              reduce using rule 28 (expr -> expr RELOP2 expr .)
    AND             reduce using rule 28 (expr -> expr RELOP2 expr .)
    RELOP2          reduce using rule 28 (expr -> expr RELOP2 expr .)
    SEMICOL         reduce using rule 28 (expr -> expr RELOP2 expr .)
    RELOP1          shift and go to state 51
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54
    MINUS           shift and go to state 55
    PLUS            shift and go to state 56


state 71

    (29) expr -> expr RELOP1 expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 29 (expr -> expr RELOP1 expr .)
    OR              reduce using rule 29 (expr -> expr RELOP1 expr .)
    AND             reduce using rule 29 (expr -> expr RELOP1 expr .)
    RELOP2          reduce using rule 29 (expr -> expr RELOP1 expr .)
    RELOP1          reduce using rule 29 (expr -> expr RELOP1 expr .)
    SEMICOL         reduce using rule 29 (expr -> expr RELOP1 expr .)
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54
    MINUS           shift and go to state 55
    PLUS            shift and go to state 56


state 72

    (32) expr -> expr MOD expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 32 (expr -> expr MOD expr .)
    OR              reduce using rule 32 (expr -> expr MOD expr .)
    AND             reduce using rule 32 (expr -> expr MOD expr .)
    RELOP2          reduce using rule 32 (expr -> expr MOD expr .)
    RELOP1          reduce using rule 32 (expr -> expr MOD expr .)
    MOD             reduce using rule 32 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 32 (expr -> expr MOD expr .)
    MULT            reduce using rule 32 (expr -> expr MOD expr .)
    MINUS           reduce using rule 32 (expr -> expr MOD expr .)
    PLUS            reduce using rule 32 (expr -> expr MOD expr .)
    SEMICOL         reduce using rule 32 (expr -> expr MOD expr .)


state 73

    (33) expr -> expr DIVIDE expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 33 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 33 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 33 (expr -> expr DIVIDE expr .)
    RELOP2          reduce using rule 33 (expr -> expr DIVIDE expr .)
    RELOP1          reduce using rule 33 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 33 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 33 (expr -> expr DIVIDE expr .)
    MULT            reduce using rule 33 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 33 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 33 (expr -> expr DIVIDE expr .)
    SEMICOL         reduce using rule 33 (expr -> expr DIVIDE expr .)


state 74

    (34) expr -> expr MULT expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 34 (expr -> expr MULT expr .)
    OR              reduce using rule 34 (expr -> expr MULT expr .)
    AND             reduce using rule 34 (expr -> expr MULT expr .)
    RELOP2          reduce using rule 34 (expr -> expr MULT expr .)
    RELOP1          reduce using rule 34 (expr -> expr MULT expr .)
    MOD             reduce using rule 34 (expr -> expr MULT expr .)
    DIVIDE          reduce using rule 34 (expr -> expr MULT expr .)
    MULT            reduce using rule 34 (expr -> expr MULT expr .)
    MINUS           reduce using rule 34 (expr -> expr MULT expr .)
    PLUS            reduce using rule 34 (expr -> expr MULT expr .)
    SEMICOL         reduce using rule 34 (expr -> expr MULT expr .)


state 75

    (35) expr -> expr MINUS expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 35 (expr -> expr MINUS expr .)
    OR              reduce using rule 35 (expr -> expr MINUS expr .)
    AND             reduce using rule 35 (expr -> expr MINUS expr .)
    RELOP2          reduce using rule 35 (expr -> expr MINUS expr .)
    RELOP1          reduce using rule 35 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 35 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 35 (expr -> expr MINUS expr .)
    SEMICOL         reduce using rule 35 (expr -> expr MINUS expr .)
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54


state 76

    (36) expr -> expr PLUS expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 36 (expr -> expr PLUS expr .)
    OR              reduce using rule 36 (expr -> expr PLUS expr .)
    AND             reduce using rule 36 (expr -> expr PLUS expr .)
    RELOP2          reduce using rule 36 (expr -> expr PLUS expr .)
    RELOP1          reduce using rule 36 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 36 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 36 (expr -> expr PLUS expr .)
    SEMICOL         reduce using rule 36 (expr -> expr PLUS expr .)
    MOD             shift and go to state 52
    DIVIDE          shift and go to state 53
    MULT            shift and go to state 54


state 77

    (56) argument -> VARNAME .
    (37) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> VARNAME . LSQB VARNAME RSQB
    (41) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> VARNAME . LSQB INTVAL RSQB
    COMMA           reduce using rule 56 (argument -> VARNAME .)
    RPAREN          reduce using rule 56 (argument -> VARNAME .)
    LSQB            shift and go to state 25


state 78

    (51) function_call -> VARNAME LPAREN argument_list . RPAREN
    RPAREN          shift and go to state 86


state 79

    (52) argument_list -> argument .
    (53) argument_list -> argument . COMMA argument_list
    RPAREN          reduce using rule 52 (argument_list -> argument .)
    COMMA           shift and go to state 87


state 80

    (54) argument -> array_variable .
    COMMA           reduce using rule 54 (argument -> array_variable .)
    RPAREN          reduce using rule 54 (argument -> array_variable .)


state 81

    (55) argument -> constant .
    COMMA           reduce using rule 55 (argument -> constant .)
    RPAREN          reduce using rule 55 (argument -> constant .)


state 82

    (37) array_variable -> VARNAME LSQB VARNAME RSQB LSQB . VARNAME RSQB
    (39) array_variable -> VARNAME LSQB VARNAME RSQB LSQB . INTVAL RSQB
    VARNAME         shift and go to state 88
    INTVAL          shift and go to state 89


state 83

    (38) array_variable -> VARNAME LSQB INTVAL RSQB LSQB . VARNAME RSQB
    (41) array_variable -> VARNAME LSQB INTVAL RSQB LSQB . INTVAL RSQB
    VARNAME         shift and go to state 90
    INTVAL          shift and go to state 91


state 84

    (22) expr -> LPAREN DATATYPE RPAREN expr .
    (26) expr -> expr . OR expr
    (27) expr -> expr . AND expr
    (28) expr -> expr . RELOP2 expr
    (29) expr -> expr . RELOP1 expr
    (32) expr -> expr . MOD expr
    (33) expr -> expr . DIVIDE expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . PLUS expr
    RPAREN          reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    OR              reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    AND             reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    RELOP2          reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    RELOP1          reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    MOD             reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    DIVIDE          reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    MULT            reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    MINUS           reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    PLUS            reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)
    SEMICOL         reduce using rule 22 (expr -> LPAREN DATATYPE RPAREN expr .)


state 85

    (9) if_statement -> IF LPAREN expr RPAREN LBRACE if_open . statements if_close RBRACE
    (1) statements -> .
    (2) statements -> . statement statements
    (3) statement -> . if_statement
    (4) statement -> . io_statement SEMICOL
    (5) statement -> . assignment_statement SEMICOL
    (6) statement -> . declaration_statement SEMICOL
    (9) if_statement -> . IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE
    (12) io_statement -> . output_statement
    (13) io_statement -> . input_statement
    (43) assignment_statement -> . left_value ASSIGN expr
    (7) declaration_statement -> . simple_init
    (15) output_statement -> . OUTPUT LPAREN constant RPAREN
    (16) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (14) input_statement -> . INPUT LPAREN left_value RPAREN
    (44) left_value -> . array_variable
    (45) left_value -> . VARNAME
    (8) simple_init -> . DATATYPE VARNAME
    (37) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> . VARNAME LSQB VARNAME RSQB
    (41) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> . VARNAME LSQB INTVAL RSQB
    RBRACE          reduce using rule 1 (statements -> .)
    IF              shift and go to state 7
    OUTPUT          shift and go to state 12
    INPUT           shift and go to state 13
    VARNAME         shift and go to state 15
    DATATYPE        shift and go to state 16

    statements                     shift and go to state 92
    statement                      shift and go to state 2
    if_statement                   shift and go to state 3
    io_statement                   shift and go to state 4
    assignment_statement           shift and go to state 5
    declaration_statement          shift and go to state 6
    output_statement               shift and go to state 8
    input_statement                shift and go to state 9
    left_value                     shift and go to state 10
    simple_init                    shift and go to state 11
    array_variable                 shift and go to state 14

state 86

    (51) function_call -> VARNAME LPAREN argument_list RPAREN .
    RPAREN          reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    OR              reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    AND             reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RELOP2          reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RELOP1          reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MOD             reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MULT            reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    SEMICOL         reduce using rule 51 (function_call -> VARNAME LPAREN argument_list RPAREN .)


state 87

    (53) argument_list -> argument COMMA . argument_list
    (52) argument_list -> . argument
    (53) argument_list -> . argument COMMA argument_list
    (54) argument -> . array_variable
    (55) argument -> . constant
    (56) argument -> . VARNAME
    (37) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (38) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (39) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (40) array_variable -> . VARNAME LSQB VARNAME RSQB
    (41) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (42) array_variable -> . VARNAME LSQB INTVAL RSQB
    (46) constant -> . BOOLVAL
    (47) constant -> . STRINGVAL
    (48) constant -> . CHARVAL
    (49) constant -> . FLOATVAL
    (50) constant -> . INTVAL
    VARNAME         shift and go to state 77
    BOOLVAL         shift and go to state 34
    STRINGVAL       shift and go to state 35
    CHARVAL         shift and go to state 36
    FLOATVAL        shift and go to state 37
    INTVAL          shift and go to state 38

    argument                       shift and go to state 79
    argument_list                  shift and go to state 93
    array_variable                 shift and go to state 80
    constant                       shift and go to state 81

state 88

    (37) array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME . RSQB
    RSQB            shift and go to state 94


state 89

    (39) array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL . RSQB
    RSQB            shift and go to state 95


state 90

    (38) array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME . RSQB
    RSQB            shift and go to state 96


state 91

    (41) array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL . RSQB
    RSQB            shift and go to state 97


state 92

    (9) if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements . if_close RBRACE
    (11) if_close -> .
    RBRACE          reduce using rule 11 (if_close -> .)

    if_close                       shift and go to state 98

state 93

    (53) argument_list -> argument COMMA argument_list .
    RPAREN          reduce using rule 53 (argument_list -> argument COMMA argument_list .)


state 94

    (37) array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .
    ASSIGN          reduce using rule 37 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 37 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)
    COMMA           reduce using rule 37 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)


state 95

    (39) array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .
    ASSIGN          reduce using rule 39 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 39 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)
    COMMA           reduce using rule 39 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)


state 96

    (38) array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .
    ASSIGN          reduce using rule 38 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 38 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)
    COMMA           reduce using rule 38 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)


state 97

    (41) array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .
    ASSIGN          reduce using rule 41 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 41 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)
    COMMA           reduce using rule 41 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)


state 98

    (9) if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close . RBRACE
    RBRACE          shift and go to state 99


state 99

    (9) if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .
    IF              reduce using rule 9 (if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .)
    OUTPUT          reduce using rule 9 (if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .)
    INPUT           reduce using rule 9 (if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .)
    VARNAME         reduce using rule 9 (if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .)
    DATATYPE        reduce using rule 9 (if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .)
    $end            reduce using rule 9 (if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .)
    RBRACE          reduce using rule 9 (if_statement -> IF LPAREN expr RPAREN LBRACE if_open statements if_close RBRACE .)
