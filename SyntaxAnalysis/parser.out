Grammar:

Rule 0     S' -> statements
Rule 1     statements -> <empty>
Rule 2     statements -> statement statements
Rule 3     statement -> start_selection selection_statement
Rule 4     statement -> io_statement SEMICOL
Rule 5     statement -> assignment_statement SEMICOL
Rule 6     statement -> declaration_statement SEMICOL
Rule 7     start_selection -> <empty>
Rule 8     selection_statement -> if_statement
Rule 9     declaration_statement -> simple_init
Rule 10    simple_init -> DATATYPE VARNAME
Rule 11    if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE
Rule 12    if_open -> <empty>
Rule 13    if_close -> <empty>
Rule 14    if_paren_open -> <empty>
Rule 15    io_statement -> output_statement
Rule 16    io_statement -> input_statement
Rule 17    input_statement -> INPUT LPAREN left_value RPAREN
Rule 18    output_statement -> OUTPUT LPAREN constant RPAREN
Rule 19    output_statement -> OUTPUT LPAREN left_value RPAREN
Rule 20    jump_statement -> return_statement
Rule 21    jump_statement -> BREAK
Rule 22    return_statement -> RETURN
Rule 23    return_statement -> RETURN expr
Rule 24    expr -> function_call
Rule 25    expr -> LPAREN DATATYPE RPAREN expr  [precedence=right, level=9]
Rule 26    expr -> constant
Rule 27    expr -> VARNAME
Rule 28    expr -> NOT expr  [precedence=right, level=10]
Rule 29    expr -> expr OR expr  [precedence=left, level=3]
Rule 30    expr -> b1_open expr b2_open AND expr  [precedence=left, level=4]
Rule 31    expr -> expr RELOP2 expr  [precedence=left, level=5]
Rule 32    expr -> expr RELOP1 expr  [precedence=left, level=6]
Rule 33    expr -> LPAREN expr RPAREN  [precedence=right, level=11]
Rule 34    expr -> MINUS expr  [precedence=right, level=10]
Rule 35    expr -> expr MOD expr  [precedence=left, level=8]
Rule 36    expr -> expr DIVIDE expr  [precedence=left, level=8]
Rule 37    expr -> expr MULT expr  [precedence=left, level=8]
Rule 38    expr -> expr MINUS expr  [precedence=left, level=7]
Rule 39    expr -> expr PLUS expr  [precedence=left, level=7]
Rule 40    b1_open -> <empty>
Rule 41    b2_open -> <empty>
Rule 42    array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
Rule 43    array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
Rule 44    array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
Rule 45    array_variable -> VARNAME LSQB VARNAME RSQB
Rule 46    array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
Rule 47    array_variable -> VARNAME LSQB INTVAL RSQB
Rule 48    assignment_statement -> left_value ASSIGN expr  [precedence=right, level=2]
Rule 49    left_value -> array_variable
Rule 50    left_value -> VARNAME
Rule 51    constant -> BOOLVAL
Rule 52    constant -> STRINGVAL
Rule 53    constant -> CHARVAL
Rule 54    constant -> FLOATVAL
Rule 55    constant -> INTVAL
Rule 56    function_call -> VARNAME LPAREN argument_list RPAREN
Rule 57    argument_list -> argument
Rule 58    argument_list -> argument COMMA argument_list  [precedence=left, level=1]
Rule 59    argument -> array_variable
Rule 60    argument -> constant
Rule 61    argument -> VARNAME

Unused terminals:

    CASE
    FUNCNAME
    FOR
    SWITCH
    ELIF
    WHILE
    COLON
    ELSE
    FUZZY
    DEFAULT

Terminals, with rules where they appear:

AND                  : 30
ASSIGN               : 48
BOOLVAL              : 51
BREAK                : 21
CASE                 : 
CHARVAL              : 53
COLON                : 
COMMA                : 58
DATATYPE             : 10 25
DEFAULT              : 
DIVIDE               : 36
ELIF                 : 
ELSE                 : 
FLOATVAL             : 54
FOR                  : 
FUNCNAME             : 
FUZZY                : 
IF                   : 11
INPUT                : 17
INTVAL               : 43 44 46 46 47 55
LBRACE               : 11
LPAREN               : 11 17 18 19 25 33 56
LSQB                 : 42 42 43 43 44 44 45 46 46 47
MINUS                : 34 38
MOD                  : 35
MULT                 : 37
NOT                  : 28
OR                   : 29
OUTPUT               : 18 19
PLUS                 : 39
RBRACE               : 11
RELOP1               : 32
RELOP2               : 31
RETURN               : 22 23
RPAREN               : 11 17 18 19 25 33 56
RSQB                 : 42 42 43 43 44 44 45 46 46 47
SEMICOL              : 4 5 6
STRINGVAL            : 52
SWITCH               : 
VARNAME              : 10 27 42 42 42 43 43 44 44 45 45 46 47 50 56 61
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

argument             : 57 58
argument_list        : 56 58
array_variable       : 49 59
assignment_statement : 5
b1_open              : 30
b2_open              : 30
constant             : 18 26 60
declaration_statement : 6
expr                 : 11 23 25 28 29 29 30 30 31 31 32 32 33 34 35 35 36 36 37 37 38 38 39 39 48
function_call        : 24
if_close             : 11
if_open              : 11
if_paren_open        : 11
if_statement         : 8
input_statement      : 16
io_statement         : 4
jump_statement       : 
left_value           : 17 19 48
output_statement     : 15
return_statement     : 20
selection_statement  : 3
simple_init          : 9
start_selection      : 3
statement            : 2
statements           : 2 11 0


state 0

    (0) S' -> . statements
    (1) statements -> .
    (2) statements -> . statement statements
    (3) statement -> . start_selection selection_statement
    (4) statement -> . io_statement SEMICOL
    (5) statement -> . assignment_statement SEMICOL
    (6) statement -> . declaration_statement SEMICOL
    (7) start_selection -> .
    (15) io_statement -> . output_statement
    (16) io_statement -> . input_statement
    (48) assignment_statement -> . left_value ASSIGN expr
    (9) declaration_statement -> . simple_init
    (18) output_statement -> . OUTPUT LPAREN constant RPAREN
    (19) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (17) input_statement -> . INPUT LPAREN left_value RPAREN
    (49) left_value -> . array_variable
    (50) left_value -> . VARNAME
    (10) simple_init -> . DATATYPE VARNAME
    (42) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> . VARNAME LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB INTVAL RSQB
    $end            reduce using rule 1 (statements -> .)
    IF              reduce using rule 7 (start_selection -> .)
    OUTPUT          shift and go to state 11
    INPUT           shift and go to state 12
    VARNAME         shift and go to state 14
    DATATYPE        shift and go to state 15

    statements                     shift and go to state 1
    statement                      shift and go to state 2
    start_selection                shift and go to state 3
    io_statement                   shift and go to state 4
    assignment_statement           shift and go to state 5
    declaration_statement          shift and go to state 6
    output_statement               shift and go to state 7
    input_statement                shift and go to state 8
    left_value                     shift and go to state 9
    simple_init                    shift and go to state 10
    array_variable                 shift and go to state 13

state 1

    (0) S' -> statements .


state 2

    (2) statements -> statement . statements
    (1) statements -> .
    (2) statements -> . statement statements
    (3) statement -> . start_selection selection_statement
    (4) statement -> . io_statement SEMICOL
    (5) statement -> . assignment_statement SEMICOL
    (6) statement -> . declaration_statement SEMICOL
    (7) start_selection -> .
    (15) io_statement -> . output_statement
    (16) io_statement -> . input_statement
    (48) assignment_statement -> . left_value ASSIGN expr
    (9) declaration_statement -> . simple_init
    (18) output_statement -> . OUTPUT LPAREN constant RPAREN
    (19) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (17) input_statement -> . INPUT LPAREN left_value RPAREN
    (49) left_value -> . array_variable
    (50) left_value -> . VARNAME
    (10) simple_init -> . DATATYPE VARNAME
    (42) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> . VARNAME LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB INTVAL RSQB
    $end            reduce using rule 1 (statements -> .)
    RBRACE          reduce using rule 1 (statements -> .)
    IF              reduce using rule 7 (start_selection -> .)
    OUTPUT          shift and go to state 11
    INPUT           shift and go to state 12
    VARNAME         shift and go to state 14
    DATATYPE        shift and go to state 15

    statement                      shift and go to state 2
    statements                     shift and go to state 16
    start_selection                shift and go to state 3
    io_statement                   shift and go to state 4
    assignment_statement           shift and go to state 5
    declaration_statement          shift and go to state 6
    output_statement               shift and go to state 7
    input_statement                shift and go to state 8
    left_value                     shift and go to state 9
    simple_init                    shift and go to state 10
    array_variable                 shift and go to state 13

state 3

    (3) statement -> start_selection . selection_statement
    (8) selection_statement -> . if_statement
    (11) if_statement -> . IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE
    IF              shift and go to state 19

    selection_statement            shift and go to state 17
    if_statement                   shift and go to state 18

state 4

    (4) statement -> io_statement . SEMICOL
    SEMICOL         shift and go to state 20


state 5

    (5) statement -> assignment_statement . SEMICOL
    SEMICOL         shift and go to state 21


state 6

    (6) statement -> declaration_statement . SEMICOL
    SEMICOL         shift and go to state 22


state 7

    (15) io_statement -> output_statement .
    SEMICOL         reduce using rule 15 (io_statement -> output_statement .)


state 8

    (16) io_statement -> input_statement .
    SEMICOL         reduce using rule 16 (io_statement -> input_statement .)


state 9

    (48) assignment_statement -> left_value . ASSIGN expr
    ASSIGN          shift and go to state 23


state 10

    (9) declaration_statement -> simple_init .
    SEMICOL         reduce using rule 9 (declaration_statement -> simple_init .)


state 11

    (18) output_statement -> OUTPUT . LPAREN constant RPAREN
    (19) output_statement -> OUTPUT . LPAREN left_value RPAREN
    LPAREN          shift and go to state 24


state 12

    (17) input_statement -> INPUT . LPAREN left_value RPAREN
    LPAREN          shift and go to state 25


state 13

    (49) left_value -> array_variable .
    ASSIGN          reduce using rule 49 (left_value -> array_variable .)
    RPAREN          reduce using rule 49 (left_value -> array_variable .)


state 14

    (50) left_value -> VARNAME .
    (42) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> VARNAME . LSQB VARNAME RSQB
    (46) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME . LSQB INTVAL RSQB
    ASSIGN          reduce using rule 50 (left_value -> VARNAME .)
    RPAREN          reduce using rule 50 (left_value -> VARNAME .)
    LSQB            shift and go to state 26


state 15

    (10) simple_init -> DATATYPE . VARNAME
    VARNAME         shift and go to state 27


state 16

    (2) statements -> statement statements .
    $end            reduce using rule 2 (statements -> statement statements .)
    RBRACE          reduce using rule 2 (statements -> statement statements .)


state 17

    (3) statement -> start_selection selection_statement .
    OUTPUT          reduce using rule 3 (statement -> start_selection selection_statement .)
    INPUT           reduce using rule 3 (statement -> start_selection selection_statement .)
    VARNAME         reduce using rule 3 (statement -> start_selection selection_statement .)
    DATATYPE        reduce using rule 3 (statement -> start_selection selection_statement .)
    IF              reduce using rule 3 (statement -> start_selection selection_statement .)
    $end            reduce using rule 3 (statement -> start_selection selection_statement .)
    RBRACE          reduce using rule 3 (statement -> start_selection selection_statement .)


state 18

    (8) selection_statement -> if_statement .
    OUTPUT          reduce using rule 8 (selection_statement -> if_statement .)
    INPUT           reduce using rule 8 (selection_statement -> if_statement .)
    VARNAME         reduce using rule 8 (selection_statement -> if_statement .)
    DATATYPE        reduce using rule 8 (selection_statement -> if_statement .)
    IF              reduce using rule 8 (selection_statement -> if_statement .)
    $end            reduce using rule 8 (selection_statement -> if_statement .)
    RBRACE          reduce using rule 8 (selection_statement -> if_statement .)


state 19

    (11) if_statement -> IF . LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE
    LPAREN          shift and go to state 28


state 20

    (4) statement -> io_statement SEMICOL .
    OUTPUT          reduce using rule 4 (statement -> io_statement SEMICOL .)
    INPUT           reduce using rule 4 (statement -> io_statement SEMICOL .)
    VARNAME         reduce using rule 4 (statement -> io_statement SEMICOL .)
    DATATYPE        reduce using rule 4 (statement -> io_statement SEMICOL .)
    IF              reduce using rule 4 (statement -> io_statement SEMICOL .)
    $end            reduce using rule 4 (statement -> io_statement SEMICOL .)
    RBRACE          reduce using rule 4 (statement -> io_statement SEMICOL .)


state 21

    (5) statement -> assignment_statement SEMICOL .
    OUTPUT          reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    INPUT           reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    VARNAME         reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    DATATYPE        reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    IF              reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    $end            reduce using rule 5 (statement -> assignment_statement SEMICOL .)
    RBRACE          reduce using rule 5 (statement -> assignment_statement SEMICOL .)


state 22

    (6) statement -> declaration_statement SEMICOL .
    OUTPUT          reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    INPUT           reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    VARNAME         reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    DATATYPE        reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    IF              reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    $end            reduce using rule 6 (statement -> declaration_statement SEMICOL .)
    RBRACE          reduce using rule 6 (statement -> declaration_statement SEMICOL .)


state 23

    (48) assignment_statement -> left_value ASSIGN . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 29
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 24

    (18) output_statement -> OUTPUT LPAREN . constant RPAREN
    (19) output_statement -> OUTPUT LPAREN . left_value RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (49) left_value -> . array_variable
    (50) left_value -> . VARNAME
    (42) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> . VARNAME LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB INTVAL RSQB
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41
    VARNAME         shift and go to state 14

    constant                       shift and go to state 42
    left_value                     shift and go to state 43
    array_variable                 shift and go to state 13

state 25

    (17) input_statement -> INPUT LPAREN . left_value RPAREN
    (49) left_value -> . array_variable
    (50) left_value -> . VARNAME
    (42) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> . VARNAME LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB INTVAL RSQB
    VARNAME         shift and go to state 14

    left_value                     shift and go to state 44
    array_variable                 shift and go to state 13

state 26

    (42) array_variable -> VARNAME LSQB . VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> VARNAME LSQB . INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> VARNAME LSQB . VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> VARNAME LSQB . VARNAME RSQB
    (46) array_variable -> VARNAME LSQB . INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME LSQB . INTVAL RSQB
    VARNAME         shift and go to state 45
    INTVAL          shift and go to state 46


state 27

    (10) simple_init -> DATATYPE VARNAME .
    SEMICOL         reduce using rule 10 (simple_init -> DATATYPE VARNAME .)


state 28

    (11) if_statement -> IF LPAREN . if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE
    (14) if_paren_open -> .
    LPAREN          reduce using rule 14 (if_paren_open -> .)
    VARNAME         reduce using rule 14 (if_paren_open -> .)
    NOT             reduce using rule 14 (if_paren_open -> .)
    MINUS           reduce using rule 14 (if_paren_open -> .)
    BOOLVAL         reduce using rule 14 (if_paren_open -> .)
    STRINGVAL       reduce using rule 14 (if_paren_open -> .)
    CHARVAL         reduce using rule 14 (if_paren_open -> .)
    FLOATVAL        reduce using rule 14 (if_paren_open -> .)
    INTVAL          reduce using rule 14 (if_paren_open -> .)

    if_paren_open                  shift and go to state 47

state 29

    (48) assignment_statement -> left_value ASSIGN expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    SEMICOL         reduce using rule 48 (assignment_statement -> left_value ASSIGN expr .)
    OR              shift and go to state 48
    RELOP2          shift and go to state 49
    RELOP1          shift and go to state 50
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55


state 30

    (24) expr -> function_call .
    OR              reduce using rule 24 (expr -> function_call .)
    RELOP2          reduce using rule 24 (expr -> function_call .)
    RELOP1          reduce using rule 24 (expr -> function_call .)
    MOD             reduce using rule 24 (expr -> function_call .)
    DIVIDE          reduce using rule 24 (expr -> function_call .)
    MULT            reduce using rule 24 (expr -> function_call .)
    MINUS           reduce using rule 24 (expr -> function_call .)
    PLUS            reduce using rule 24 (expr -> function_call .)
    SEMICOL         reduce using rule 24 (expr -> function_call .)
    RPAREN          reduce using rule 24 (expr -> function_call .)
    AND             reduce using rule 24 (expr -> function_call .)


state 31

    (25) expr -> LPAREN . DATATYPE RPAREN expr
    (33) expr -> LPAREN . expr RPAREN
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    DATATYPE        shift and go to state 56
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 57
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 32

    (26) expr -> constant .
    OR              reduce using rule 26 (expr -> constant .)
    RELOP2          reduce using rule 26 (expr -> constant .)
    RELOP1          reduce using rule 26 (expr -> constant .)
    MOD             reduce using rule 26 (expr -> constant .)
    DIVIDE          reduce using rule 26 (expr -> constant .)
    MULT            reduce using rule 26 (expr -> constant .)
    MINUS           reduce using rule 26 (expr -> constant .)
    PLUS            reduce using rule 26 (expr -> constant .)
    SEMICOL         reduce using rule 26 (expr -> constant .)
    RPAREN          reduce using rule 26 (expr -> constant .)
    AND             reduce using rule 26 (expr -> constant .)


state 33

    (27) expr -> VARNAME .
    (56) function_call -> VARNAME . LPAREN argument_list RPAREN
    OR              reduce using rule 27 (expr -> VARNAME .)
    RELOP2          reduce using rule 27 (expr -> VARNAME .)
    RELOP1          reduce using rule 27 (expr -> VARNAME .)
    MOD             reduce using rule 27 (expr -> VARNAME .)
    DIVIDE          reduce using rule 27 (expr -> VARNAME .)
    MULT            reduce using rule 27 (expr -> VARNAME .)
    MINUS           reduce using rule 27 (expr -> VARNAME .)
    PLUS            reduce using rule 27 (expr -> VARNAME .)
    SEMICOL         reduce using rule 27 (expr -> VARNAME .)
    RPAREN          reduce using rule 27 (expr -> VARNAME .)
    AND             reduce using rule 27 (expr -> VARNAME .)
    LPAREN          shift and go to state 58


state 34

    (28) expr -> NOT . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 59
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 35

    (30) expr -> b1_open . expr b2_open AND expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    b1_open                        shift and go to state 35
    expr                           shift and go to state 60
    function_call                  shift and go to state 30
    constant                       shift and go to state 32

state 36

    (34) expr -> MINUS . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 61
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 37

    (51) constant -> BOOLVAL .
    OR              reduce using rule 51 (constant -> BOOLVAL .)
    RELOP2          reduce using rule 51 (constant -> BOOLVAL .)
    RELOP1          reduce using rule 51 (constant -> BOOLVAL .)
    MOD             reduce using rule 51 (constant -> BOOLVAL .)
    DIVIDE          reduce using rule 51 (constant -> BOOLVAL .)
    MULT            reduce using rule 51 (constant -> BOOLVAL .)
    MINUS           reduce using rule 51 (constant -> BOOLVAL .)
    PLUS            reduce using rule 51 (constant -> BOOLVAL .)
    SEMICOL         reduce using rule 51 (constant -> BOOLVAL .)
    RPAREN          reduce using rule 51 (constant -> BOOLVAL .)
    AND             reduce using rule 51 (constant -> BOOLVAL .)
    COMMA           reduce using rule 51 (constant -> BOOLVAL .)


state 38

    (52) constant -> STRINGVAL .
    OR              reduce using rule 52 (constant -> STRINGVAL .)
    RELOP2          reduce using rule 52 (constant -> STRINGVAL .)
    RELOP1          reduce using rule 52 (constant -> STRINGVAL .)
    MOD             reduce using rule 52 (constant -> STRINGVAL .)
    DIVIDE          reduce using rule 52 (constant -> STRINGVAL .)
    MULT            reduce using rule 52 (constant -> STRINGVAL .)
    MINUS           reduce using rule 52 (constant -> STRINGVAL .)
    PLUS            reduce using rule 52 (constant -> STRINGVAL .)
    SEMICOL         reduce using rule 52 (constant -> STRINGVAL .)
    RPAREN          reduce using rule 52 (constant -> STRINGVAL .)
    AND             reduce using rule 52 (constant -> STRINGVAL .)
    COMMA           reduce using rule 52 (constant -> STRINGVAL .)


state 39

    (53) constant -> CHARVAL .
    OR              reduce using rule 53 (constant -> CHARVAL .)
    RELOP2          reduce using rule 53 (constant -> CHARVAL .)
    RELOP1          reduce using rule 53 (constant -> CHARVAL .)
    MOD             reduce using rule 53 (constant -> CHARVAL .)
    DIVIDE          reduce using rule 53 (constant -> CHARVAL .)
    MULT            reduce using rule 53 (constant -> CHARVAL .)
    MINUS           reduce using rule 53 (constant -> CHARVAL .)
    PLUS            reduce using rule 53 (constant -> CHARVAL .)
    SEMICOL         reduce using rule 53 (constant -> CHARVAL .)
    RPAREN          reduce using rule 53 (constant -> CHARVAL .)
    AND             reduce using rule 53 (constant -> CHARVAL .)
    COMMA           reduce using rule 53 (constant -> CHARVAL .)


state 40

    (54) constant -> FLOATVAL .
    OR              reduce using rule 54 (constant -> FLOATVAL .)
    RELOP2          reduce using rule 54 (constant -> FLOATVAL .)
    RELOP1          reduce using rule 54 (constant -> FLOATVAL .)
    MOD             reduce using rule 54 (constant -> FLOATVAL .)
    DIVIDE          reduce using rule 54 (constant -> FLOATVAL .)
    MULT            reduce using rule 54 (constant -> FLOATVAL .)
    MINUS           reduce using rule 54 (constant -> FLOATVAL .)
    PLUS            reduce using rule 54 (constant -> FLOATVAL .)
    SEMICOL         reduce using rule 54 (constant -> FLOATVAL .)
    RPAREN          reduce using rule 54 (constant -> FLOATVAL .)
    AND             reduce using rule 54 (constant -> FLOATVAL .)
    COMMA           reduce using rule 54 (constant -> FLOATVAL .)


state 41

    (55) constant -> INTVAL .
    OR              reduce using rule 55 (constant -> INTVAL .)
    RELOP2          reduce using rule 55 (constant -> INTVAL .)
    RELOP1          reduce using rule 55 (constant -> INTVAL .)
    MOD             reduce using rule 55 (constant -> INTVAL .)
    DIVIDE          reduce using rule 55 (constant -> INTVAL .)
    MULT            reduce using rule 55 (constant -> INTVAL .)
    MINUS           reduce using rule 55 (constant -> INTVAL .)
    PLUS            reduce using rule 55 (constant -> INTVAL .)
    SEMICOL         reduce using rule 55 (constant -> INTVAL .)
    RPAREN          reduce using rule 55 (constant -> INTVAL .)
    AND             reduce using rule 55 (constant -> INTVAL .)
    COMMA           reduce using rule 55 (constant -> INTVAL .)


state 42

    (18) output_statement -> OUTPUT LPAREN constant . RPAREN
    RPAREN          shift and go to state 62


state 43

    (19) output_statement -> OUTPUT LPAREN left_value . RPAREN
    RPAREN          shift and go to state 63


state 44

    (17) input_statement -> INPUT LPAREN left_value . RPAREN
    RPAREN          shift and go to state 64


state 45

    (42) array_variable -> VARNAME LSQB VARNAME . RSQB LSQB VARNAME RSQB
    (44) array_variable -> VARNAME LSQB VARNAME . RSQB LSQB INTVAL RSQB
    (45) array_variable -> VARNAME LSQB VARNAME . RSQB
    RSQB            shift and go to state 65


state 46

    (43) array_variable -> VARNAME LSQB INTVAL . RSQB LSQB VARNAME RSQB
    (46) array_variable -> VARNAME LSQB INTVAL . RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME LSQB INTVAL . RSQB
    RSQB            shift and go to state 66


state 47

    (11) if_statement -> IF LPAREN if_paren_open . expr RPAREN LBRACE if_open statements if_close RBRACE
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 67
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 48

    (29) expr -> expr OR . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 68
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 49

    (31) expr -> expr RELOP2 . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 69
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 50

    (32) expr -> expr RELOP1 . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 70
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 51

    (35) expr -> expr MOD . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 71
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 52

    (36) expr -> expr DIVIDE . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 72
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 53

    (37) expr -> expr MULT . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 73
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 54

    (38) expr -> expr MINUS . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 74
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 55

    (39) expr -> expr PLUS . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 75
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 56

    (25) expr -> LPAREN DATATYPE . RPAREN expr
    RPAREN          shift and go to state 76


state 57

    (33) expr -> LPAREN expr . RPAREN
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    RPAREN          shift and go to state 77
    OR              shift and go to state 48
    RELOP2          shift and go to state 49
    RELOP1          shift and go to state 50
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55


state 58

    (56) function_call -> VARNAME LPAREN . argument_list RPAREN
    (57) argument_list -> . argument
    (58) argument_list -> . argument COMMA argument_list
    (59) argument -> . array_variable
    (60) argument -> . constant
    (61) argument -> . VARNAME
    (42) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> . VARNAME LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB INTVAL RSQB
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    VARNAME         shift and go to state 78
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    argument_list                  shift and go to state 79
    argument                       shift and go to state 80
    array_variable                 shift and go to state 81
    constant                       shift and go to state 82

state 59

    (28) expr -> NOT expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 28 (expr -> NOT expr .)
    RELOP2          reduce using rule 28 (expr -> NOT expr .)
    RELOP1          reduce using rule 28 (expr -> NOT expr .)
    MOD             reduce using rule 28 (expr -> NOT expr .)
    DIVIDE          reduce using rule 28 (expr -> NOT expr .)
    MULT            reduce using rule 28 (expr -> NOT expr .)
    MINUS           reduce using rule 28 (expr -> NOT expr .)
    PLUS            reduce using rule 28 (expr -> NOT expr .)
    SEMICOL         reduce using rule 28 (expr -> NOT expr .)
    RPAREN          reduce using rule 28 (expr -> NOT expr .)
    AND             reduce using rule 28 (expr -> NOT expr .)


state 60

    (30) expr -> b1_open expr . b2_open AND expr
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    (41) b2_open -> .
    OR              shift and go to state 48
    RELOP2          shift and go to state 49
    RELOP1          shift and go to state 50
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55
    AND             reduce using rule 41 (b2_open -> .)

    b2_open                        shift and go to state 83

state 61

    (34) expr -> MINUS expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 34 (expr -> MINUS expr .)
    RELOP2          reduce using rule 34 (expr -> MINUS expr .)
    RELOP1          reduce using rule 34 (expr -> MINUS expr .)
    MOD             reduce using rule 34 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 34 (expr -> MINUS expr .)
    MULT            reduce using rule 34 (expr -> MINUS expr .)
    MINUS           reduce using rule 34 (expr -> MINUS expr .)
    PLUS            reduce using rule 34 (expr -> MINUS expr .)
    SEMICOL         reduce using rule 34 (expr -> MINUS expr .)
    RPAREN          reduce using rule 34 (expr -> MINUS expr .)
    AND             reduce using rule 34 (expr -> MINUS expr .)


state 62

    (18) output_statement -> OUTPUT LPAREN constant RPAREN .
    SEMICOL         reduce using rule 18 (output_statement -> OUTPUT LPAREN constant RPAREN .)


state 63

    (19) output_statement -> OUTPUT LPAREN left_value RPAREN .
    SEMICOL         reduce using rule 19 (output_statement -> OUTPUT LPAREN left_value RPAREN .)


state 64

    (17) input_statement -> INPUT LPAREN left_value RPAREN .
    SEMICOL         reduce using rule 17 (input_statement -> INPUT LPAREN left_value RPAREN .)


state 65

    (42) array_variable -> VARNAME LSQB VARNAME RSQB . LSQB VARNAME RSQB
    (44) array_variable -> VARNAME LSQB VARNAME RSQB . LSQB INTVAL RSQB
    (45) array_variable -> VARNAME LSQB VARNAME RSQB .
    LSQB            shift and go to state 84
    ASSIGN          reduce using rule 45 (array_variable -> VARNAME LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 45 (array_variable -> VARNAME LSQB VARNAME RSQB .)
    COMMA           reduce using rule 45 (array_variable -> VARNAME LSQB VARNAME RSQB .)


state 66

    (43) array_variable -> VARNAME LSQB INTVAL RSQB . LSQB VARNAME RSQB
    (46) array_variable -> VARNAME LSQB INTVAL RSQB . LSQB INTVAL RSQB
    (47) array_variable -> VARNAME LSQB INTVAL RSQB .
    LSQB            shift and go to state 85
    ASSIGN          reduce using rule 47 (array_variable -> VARNAME LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 47 (array_variable -> VARNAME LSQB INTVAL RSQB .)
    COMMA           reduce using rule 47 (array_variable -> VARNAME LSQB INTVAL RSQB .)


state 67

    (11) if_statement -> IF LPAREN if_paren_open expr . RPAREN LBRACE if_open statements if_close RBRACE
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    RPAREN          shift and go to state 86
    OR              shift and go to state 48
    RELOP2          shift and go to state 49
    RELOP1          shift and go to state 50
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55


state 68

    (29) expr -> expr OR expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 29 (expr -> expr OR expr .)
    SEMICOL         reduce using rule 29 (expr -> expr OR expr .)
    RPAREN          reduce using rule 29 (expr -> expr OR expr .)
    AND             reduce using rule 29 (expr -> expr OR expr .)
    RELOP2          shift and go to state 49
    RELOP1          shift and go to state 50
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55


state 69

    (31) expr -> expr RELOP2 expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 31 (expr -> expr RELOP2 expr .)
    RELOP2          reduce using rule 31 (expr -> expr RELOP2 expr .)
    SEMICOL         reduce using rule 31 (expr -> expr RELOP2 expr .)
    RPAREN          reduce using rule 31 (expr -> expr RELOP2 expr .)
    AND             reduce using rule 31 (expr -> expr RELOP2 expr .)
    RELOP1          shift and go to state 50
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55


state 70

    (32) expr -> expr RELOP1 expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 32 (expr -> expr RELOP1 expr .)
    RELOP2          reduce using rule 32 (expr -> expr RELOP1 expr .)
    RELOP1          reduce using rule 32 (expr -> expr RELOP1 expr .)
    SEMICOL         reduce using rule 32 (expr -> expr RELOP1 expr .)
    RPAREN          reduce using rule 32 (expr -> expr RELOP1 expr .)
    AND             reduce using rule 32 (expr -> expr RELOP1 expr .)
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55


state 71

    (35) expr -> expr MOD expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 35 (expr -> expr MOD expr .)
    RELOP2          reduce using rule 35 (expr -> expr MOD expr .)
    RELOP1          reduce using rule 35 (expr -> expr MOD expr .)
    MOD             reduce using rule 35 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 35 (expr -> expr MOD expr .)
    MULT            reduce using rule 35 (expr -> expr MOD expr .)
    MINUS           reduce using rule 35 (expr -> expr MOD expr .)
    PLUS            reduce using rule 35 (expr -> expr MOD expr .)
    SEMICOL         reduce using rule 35 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 35 (expr -> expr MOD expr .)
    AND             reduce using rule 35 (expr -> expr MOD expr .)


state 72

    (36) expr -> expr DIVIDE expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 36 (expr -> expr DIVIDE expr .)
    RELOP2          reduce using rule 36 (expr -> expr DIVIDE expr .)
    RELOP1          reduce using rule 36 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 36 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 36 (expr -> expr DIVIDE expr .)
    MULT            reduce using rule 36 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 36 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 36 (expr -> expr DIVIDE expr .)
    SEMICOL         reduce using rule 36 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 36 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 36 (expr -> expr DIVIDE expr .)


state 73

    (37) expr -> expr MULT expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 37 (expr -> expr MULT expr .)
    RELOP2          reduce using rule 37 (expr -> expr MULT expr .)
    RELOP1          reduce using rule 37 (expr -> expr MULT expr .)
    MOD             reduce using rule 37 (expr -> expr MULT expr .)
    DIVIDE          reduce using rule 37 (expr -> expr MULT expr .)
    MULT            reduce using rule 37 (expr -> expr MULT expr .)
    MINUS           reduce using rule 37 (expr -> expr MULT expr .)
    PLUS            reduce using rule 37 (expr -> expr MULT expr .)
    SEMICOL         reduce using rule 37 (expr -> expr MULT expr .)
    RPAREN          reduce using rule 37 (expr -> expr MULT expr .)
    AND             reduce using rule 37 (expr -> expr MULT expr .)


state 74

    (38) expr -> expr MINUS expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 38 (expr -> expr MINUS expr .)
    RELOP2          reduce using rule 38 (expr -> expr MINUS expr .)
    RELOP1          reduce using rule 38 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 38 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 38 (expr -> expr MINUS expr .)
    SEMICOL         reduce using rule 38 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 38 (expr -> expr MINUS expr .)
    AND             reduce using rule 38 (expr -> expr MINUS expr .)
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53


state 75

    (39) expr -> expr PLUS expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 39 (expr -> expr PLUS expr .)
    RELOP2          reduce using rule 39 (expr -> expr PLUS expr .)
    RELOP1          reduce using rule 39 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 39 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 39 (expr -> expr PLUS expr .)
    SEMICOL         reduce using rule 39 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 39 (expr -> expr PLUS expr .)
    AND             reduce using rule 39 (expr -> expr PLUS expr .)
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53


state 76

    (25) expr -> LPAREN DATATYPE RPAREN . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    expr                           shift and go to state 87
    function_call                  shift and go to state 30
    constant                       shift and go to state 32
    b1_open                        shift and go to state 35

state 77

    (33) expr -> LPAREN expr RPAREN .
    OR              reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    RELOP2          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    RELOP1          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    SEMICOL         reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 33 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 33 (expr -> LPAREN expr RPAREN .)


state 78

    (61) argument -> VARNAME .
    (42) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> VARNAME . LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> VARNAME . LSQB VARNAME RSQB
    (46) array_variable -> VARNAME . LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> VARNAME . LSQB INTVAL RSQB
    COMMA           reduce using rule 61 (argument -> VARNAME .)
    RPAREN          reduce using rule 61 (argument -> VARNAME .)
    LSQB            shift and go to state 26


state 79

    (56) function_call -> VARNAME LPAREN argument_list . RPAREN
    RPAREN          shift and go to state 88


state 80

    (57) argument_list -> argument .
    (58) argument_list -> argument . COMMA argument_list
    RPAREN          reduce using rule 57 (argument_list -> argument .)
    COMMA           shift and go to state 89


state 81

    (59) argument -> array_variable .
    COMMA           reduce using rule 59 (argument -> array_variable .)
    RPAREN          reduce using rule 59 (argument -> array_variable .)


state 82

    (60) argument -> constant .
    COMMA           reduce using rule 60 (argument -> constant .)
    RPAREN          reduce using rule 60 (argument -> constant .)


state 83

    (30) expr -> b1_open expr b2_open . AND expr
    AND             shift and go to state 90


state 84

    (42) array_variable -> VARNAME LSQB VARNAME RSQB LSQB . VARNAME RSQB
    (44) array_variable -> VARNAME LSQB VARNAME RSQB LSQB . INTVAL RSQB
    VARNAME         shift and go to state 91
    INTVAL          shift and go to state 92


state 85

    (43) array_variable -> VARNAME LSQB INTVAL RSQB LSQB . VARNAME RSQB
    (46) array_variable -> VARNAME LSQB INTVAL RSQB LSQB . INTVAL RSQB
    VARNAME         shift and go to state 93
    INTVAL          shift and go to state 94


state 86

    (11) if_statement -> IF LPAREN if_paren_open expr RPAREN . LBRACE if_open statements if_close RBRACE
    LBRACE          shift and go to state 95


state 87

    (25) expr -> LPAREN DATATYPE RPAREN expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    RELOP2          reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    RELOP1          reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    MOD             reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    DIVIDE          reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    MULT            reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    MINUS           reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    PLUS            reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    SEMICOL         reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    RPAREN          reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)
    AND             reduce using rule 25 (expr -> LPAREN DATATYPE RPAREN expr .)


state 88

    (56) function_call -> VARNAME LPAREN argument_list RPAREN .
    OR              reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RELOP2          reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RELOP1          reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MOD             reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MULT            reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    SEMICOL         reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)
    AND             reduce using rule 56 (function_call -> VARNAME LPAREN argument_list RPAREN .)


state 89

    (58) argument_list -> argument COMMA . argument_list
    (57) argument_list -> . argument
    (58) argument_list -> . argument COMMA argument_list
    (59) argument -> . array_variable
    (60) argument -> . constant
    (61) argument -> . VARNAME
    (42) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> . VARNAME LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB INTVAL RSQB
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    VARNAME         shift and go to state 78
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    argument                       shift and go to state 80
    argument_list                  shift and go to state 96
    array_variable                 shift and go to state 81
    constant                       shift and go to state 82

state 90

    (30) expr -> b1_open expr b2_open AND . expr
    (24) expr -> . function_call
    (25) expr -> . LPAREN DATATYPE RPAREN expr
    (26) expr -> . constant
    (27) expr -> . VARNAME
    (28) expr -> . NOT expr
    (29) expr -> . expr OR expr
    (30) expr -> . b1_open expr b2_open AND expr
    (31) expr -> . expr RELOP2 expr
    (32) expr -> . expr RELOP1 expr
    (33) expr -> . LPAREN expr RPAREN
    (34) expr -> . MINUS expr
    (35) expr -> . expr MOD expr
    (36) expr -> . expr DIVIDE expr
    (37) expr -> . expr MULT expr
    (38) expr -> . expr MINUS expr
    (39) expr -> . expr PLUS expr
    (56) function_call -> . VARNAME LPAREN argument_list RPAREN
    (51) constant -> . BOOLVAL
    (52) constant -> . STRINGVAL
    (53) constant -> . CHARVAL
    (54) constant -> . FLOATVAL
    (55) constant -> . INTVAL
    (40) b1_open -> .
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VARNAME resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BOOLVAL resolved as shift
  ! shift/reduce conflict for STRINGVAL resolved as shift
  ! shift/reduce conflict for CHARVAL resolved as shift
  ! shift/reduce conflict for FLOATVAL resolved as shift
  ! shift/reduce conflict for INTVAL resolved as shift
    LPAREN          shift and go to state 31
    VARNAME         shift and go to state 33
    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    BOOLVAL         shift and go to state 37
    STRINGVAL       shift and go to state 38
    CHARVAL         shift and go to state 39
    FLOATVAL        shift and go to state 40
    INTVAL          shift and go to state 41

    b1_open                        shift and go to state 35
    expr                           shift and go to state 97
    function_call                  shift and go to state 30
    constant                       shift and go to state 32

state 91

    (42) array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME . RSQB
    RSQB            shift and go to state 98


state 92

    (44) array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL . RSQB
    RSQB            shift and go to state 99


state 93

    (43) array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME . RSQB
    RSQB            shift and go to state 100


state 94

    (46) array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL . RSQB
    RSQB            shift and go to state 101


state 95

    (11) if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE . if_open statements if_close RBRACE
    (12) if_open -> .
    OUTPUT          reduce using rule 12 (if_open -> .)
    INPUT           reduce using rule 12 (if_open -> .)
    VARNAME         reduce using rule 12 (if_open -> .)
    DATATYPE        reduce using rule 12 (if_open -> .)
    RBRACE          reduce using rule 12 (if_open -> .)
    IF              reduce using rule 12 (if_open -> .)

    if_open                        shift and go to state 102

state 96

    (58) argument_list -> argument COMMA argument_list .
    RPAREN          reduce using rule 58 (argument_list -> argument COMMA argument_list .)


state 97

    (30) expr -> b1_open expr b2_open AND expr .
    (29) expr -> expr . OR expr
    (31) expr -> expr . RELOP2 expr
    (32) expr -> expr . RELOP1 expr
    (35) expr -> expr . MOD expr
    (36) expr -> expr . DIVIDE expr
    (37) expr -> expr . MULT expr
    (38) expr -> expr . MINUS expr
    (39) expr -> expr . PLUS expr
    OR              reduce using rule 30 (expr -> b1_open expr b2_open AND expr .)
    SEMICOL         reduce using rule 30 (expr -> b1_open expr b2_open AND expr .)
    RPAREN          reduce using rule 30 (expr -> b1_open expr b2_open AND expr .)
    AND             reduce using rule 30 (expr -> b1_open expr b2_open AND expr .)
    RELOP2          shift and go to state 49
    RELOP1          shift and go to state 50
    MOD             shift and go to state 51
    DIVIDE          shift and go to state 52
    MULT            shift and go to state 53
    MINUS           shift and go to state 54
    PLUS            shift and go to state 55


state 98

    (42) array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .
    ASSIGN          reduce using rule 42 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 42 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)
    COMMA           reduce using rule 42 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB .)


state 99

    (44) array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .
    ASSIGN          reduce using rule 44 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 44 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)
    COMMA           reduce using rule 44 (array_variable -> VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB .)


state 100

    (43) array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .
    ASSIGN          reduce using rule 43 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)
    RPAREN          reduce using rule 43 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)
    COMMA           reduce using rule 43 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB .)


state 101

    (46) array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .
    ASSIGN          reduce using rule 46 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)
    RPAREN          reduce using rule 46 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)
    COMMA           reduce using rule 46 (array_variable -> VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB .)


state 102

    (11) if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open . statements if_close RBRACE
    (1) statements -> .
    (2) statements -> . statement statements
    (3) statement -> . start_selection selection_statement
    (4) statement -> . io_statement SEMICOL
    (5) statement -> . assignment_statement SEMICOL
    (6) statement -> . declaration_statement SEMICOL
    (7) start_selection -> .
    (15) io_statement -> . output_statement
    (16) io_statement -> . input_statement
    (48) assignment_statement -> . left_value ASSIGN expr
    (9) declaration_statement -> . simple_init
    (18) output_statement -> . OUTPUT LPAREN constant RPAREN
    (19) output_statement -> . OUTPUT LPAREN left_value RPAREN
    (17) input_statement -> . INPUT LPAREN left_value RPAREN
    (49) left_value -> . array_variable
    (50) left_value -> . VARNAME
    (10) simple_init -> . DATATYPE VARNAME
    (42) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB VARNAME RSQB
    (43) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB VARNAME RSQB
    (44) array_variable -> . VARNAME LSQB VARNAME RSQB LSQB INTVAL RSQB
    (45) array_variable -> . VARNAME LSQB VARNAME RSQB
    (46) array_variable -> . VARNAME LSQB INTVAL RSQB LSQB INTVAL RSQB
    (47) array_variable -> . VARNAME LSQB INTVAL RSQB
    RBRACE          reduce using rule 1 (statements -> .)
    IF              reduce using rule 7 (start_selection -> .)
    OUTPUT          shift and go to state 11
    INPUT           shift and go to state 12
    VARNAME         shift and go to state 14
    DATATYPE        shift and go to state 15

    statements                     shift and go to state 103
    statement                      shift and go to state 2
    start_selection                shift and go to state 3
    io_statement                   shift and go to state 4
    assignment_statement           shift and go to state 5
    declaration_statement          shift and go to state 6
    output_statement               shift and go to state 7
    input_statement                shift and go to state 8
    left_value                     shift and go to state 9
    simple_init                    shift and go to state 10
    array_variable                 shift and go to state 13

state 103

    (11) if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements . if_close RBRACE
    (13) if_close -> .
    RBRACE          reduce using rule 13 (if_close -> .)

    if_close                       shift and go to state 104

state 104

    (11) if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close . RBRACE
    RBRACE          shift and go to state 105


state 105

    (11) if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .
    OUTPUT          reduce using rule 11 (if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .)
    INPUT           reduce using rule 11 (if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .)
    VARNAME         reduce using rule 11 (if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .)
    DATATYPE        reduce using rule 11 (if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .)
    IF              reduce using rule 11 (if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .)
    $end            reduce using rule 11 (if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .)
    RBRACE          reduce using rule 11 (if_statement -> IF LPAREN if_paren_open expr RPAREN LBRACE if_open statements if_close RBRACE .)


Conflicts:

shift/reduce conflict for LPAREN in state 23 resolved as shift
shift/reduce conflict for VARNAME in state 23 resolved as shift
shift/reduce conflict for NOT in state 23 resolved as shift
shift/reduce conflict for MINUS in state 23 resolved as shift
shift/reduce conflict for BOOLVAL in state 23 resolved as shift
shift/reduce conflict for STRINGVAL in state 23 resolved as shift
shift/reduce conflict for CHARVAL in state 23 resolved as shift
shift/reduce conflict for FLOATVAL in state 23 resolved as shift
shift/reduce conflict for INTVAL in state 23 resolved as shift
shift/reduce conflict for LPAREN in state 31 resolved as shift
shift/reduce conflict for VARNAME in state 31 resolved as shift
shift/reduce conflict for NOT in state 31 resolved as shift
shift/reduce conflict for MINUS in state 31 resolved as shift
shift/reduce conflict for BOOLVAL in state 31 resolved as shift
shift/reduce conflict for STRINGVAL in state 31 resolved as shift
shift/reduce conflict for CHARVAL in state 31 resolved as shift
shift/reduce conflict for FLOATVAL in state 31 resolved as shift
shift/reduce conflict for INTVAL in state 31 resolved as shift
shift/reduce conflict for LPAREN in state 34 resolved as shift
shift/reduce conflict for VARNAME in state 34 resolved as shift
shift/reduce conflict for NOT in state 34 resolved as shift
shift/reduce conflict for MINUS in state 34 resolved as shift
shift/reduce conflict for BOOLVAL in state 34 resolved as shift
shift/reduce conflict for STRINGVAL in state 34 resolved as shift
shift/reduce conflict for CHARVAL in state 34 resolved as shift
shift/reduce conflict for FLOATVAL in state 34 resolved as shift
shift/reduce conflict for INTVAL in state 34 resolved as shift
shift/reduce conflict for LPAREN in state 35 resolved as shift
shift/reduce conflict for VARNAME in state 35 resolved as shift
shift/reduce conflict for NOT in state 35 resolved as shift
shift/reduce conflict for MINUS in state 35 resolved as shift
shift/reduce conflict for BOOLVAL in state 35 resolved as shift
shift/reduce conflict for STRINGVAL in state 35 resolved as shift
shift/reduce conflict for CHARVAL in state 35 resolved as shift
shift/reduce conflict for FLOATVAL in state 35 resolved as shift
shift/reduce conflict for INTVAL in state 35 resolved as shift
shift/reduce conflict for LPAREN in state 36 resolved as shift
shift/reduce conflict for VARNAME in state 36 resolved as shift
shift/reduce conflict for NOT in state 36 resolved as shift
shift/reduce conflict for MINUS in state 36 resolved as shift
shift/reduce conflict for BOOLVAL in state 36 resolved as shift
shift/reduce conflict for STRINGVAL in state 36 resolved as shift
shift/reduce conflict for CHARVAL in state 36 resolved as shift
shift/reduce conflict for FLOATVAL in state 36 resolved as shift
shift/reduce conflict for INTVAL in state 36 resolved as shift
shift/reduce conflict for LPAREN in state 47 resolved as shift
shift/reduce conflict for VARNAME in state 47 resolved as shift
shift/reduce conflict for NOT in state 47 resolved as shift
shift/reduce conflict for MINUS in state 47 resolved as shift
shift/reduce conflict for BOOLVAL in state 47 resolved as shift
shift/reduce conflict for STRINGVAL in state 47 resolved as shift
shift/reduce conflict for CHARVAL in state 47 resolved as shift
shift/reduce conflict for FLOATVAL in state 47 resolved as shift
shift/reduce conflict for INTVAL in state 47 resolved as shift
shift/reduce conflict for LPAREN in state 48 resolved as shift
shift/reduce conflict for VARNAME in state 48 resolved as shift
shift/reduce conflict for NOT in state 48 resolved as shift
shift/reduce conflict for MINUS in state 48 resolved as shift
shift/reduce conflict for BOOLVAL in state 48 resolved as shift
shift/reduce conflict for STRINGVAL in state 48 resolved as shift
shift/reduce conflict for CHARVAL in state 48 resolved as shift
shift/reduce conflict for FLOATVAL in state 48 resolved as shift
shift/reduce conflict for INTVAL in state 48 resolved as shift
shift/reduce conflict for LPAREN in state 49 resolved as shift
shift/reduce conflict for VARNAME in state 49 resolved as shift
shift/reduce conflict for NOT in state 49 resolved as shift
shift/reduce conflict for MINUS in state 49 resolved as shift
shift/reduce conflict for BOOLVAL in state 49 resolved as shift
shift/reduce conflict for STRINGVAL in state 49 resolved as shift
shift/reduce conflict for CHARVAL in state 49 resolved as shift
shift/reduce conflict for FLOATVAL in state 49 resolved as shift
shift/reduce conflict for INTVAL in state 49 resolved as shift
shift/reduce conflict for LPAREN in state 50 resolved as shift
shift/reduce conflict for VARNAME in state 50 resolved as shift
shift/reduce conflict for NOT in state 50 resolved as shift
shift/reduce conflict for MINUS in state 50 resolved as shift
shift/reduce conflict for BOOLVAL in state 50 resolved as shift
shift/reduce conflict for STRINGVAL in state 50 resolved as shift
shift/reduce conflict for CHARVAL in state 50 resolved as shift
shift/reduce conflict for FLOATVAL in state 50 resolved as shift
shift/reduce conflict for INTVAL in state 50 resolved as shift
shift/reduce conflict for LPAREN in state 51 resolved as shift
shift/reduce conflict for VARNAME in state 51 resolved as shift
shift/reduce conflict for NOT in state 51 resolved as shift
shift/reduce conflict for MINUS in state 51 resolved as shift
shift/reduce conflict for BOOLVAL in state 51 resolved as shift
shift/reduce conflict for STRINGVAL in state 51 resolved as shift
shift/reduce conflict for CHARVAL in state 51 resolved as shift
shift/reduce conflict for FLOATVAL in state 51 resolved as shift
shift/reduce conflict for INTVAL in state 51 resolved as shift
shift/reduce conflict for LPAREN in state 52 resolved as shift
shift/reduce conflict for VARNAME in state 52 resolved as shift
shift/reduce conflict for NOT in state 52 resolved as shift
shift/reduce conflict for MINUS in state 52 resolved as shift
shift/reduce conflict for BOOLVAL in state 52 resolved as shift
shift/reduce conflict for STRINGVAL in state 52 resolved as shift
shift/reduce conflict for CHARVAL in state 52 resolved as shift
shift/reduce conflict for FLOATVAL in state 52 resolved as shift
shift/reduce conflict for INTVAL in state 52 resolved as shift
shift/reduce conflict for LPAREN in state 53 resolved as shift
shift/reduce conflict for VARNAME in state 53 resolved as shift
shift/reduce conflict for NOT in state 53 resolved as shift
shift/reduce conflict for MINUS in state 53 resolved as shift
shift/reduce conflict for BOOLVAL in state 53 resolved as shift
shift/reduce conflict for STRINGVAL in state 53 resolved as shift
shift/reduce conflict for CHARVAL in state 53 resolved as shift
shift/reduce conflict for FLOATVAL in state 53 resolved as shift
shift/reduce conflict for INTVAL in state 53 resolved as shift
shift/reduce conflict for LPAREN in state 54 resolved as shift
shift/reduce conflict for VARNAME in state 54 resolved as shift
shift/reduce conflict for NOT in state 54 resolved as shift
shift/reduce conflict for MINUS in state 54 resolved as shift
shift/reduce conflict for BOOLVAL in state 54 resolved as shift
shift/reduce conflict for STRINGVAL in state 54 resolved as shift
shift/reduce conflict for CHARVAL in state 54 resolved as shift
shift/reduce conflict for FLOATVAL in state 54 resolved as shift
shift/reduce conflict for INTVAL in state 54 resolved as shift
shift/reduce conflict for LPAREN in state 55 resolved as shift
shift/reduce conflict for VARNAME in state 55 resolved as shift
shift/reduce conflict for NOT in state 55 resolved as shift
shift/reduce conflict for MINUS in state 55 resolved as shift
shift/reduce conflict for BOOLVAL in state 55 resolved as shift
shift/reduce conflict for STRINGVAL in state 55 resolved as shift
shift/reduce conflict for CHARVAL in state 55 resolved as shift
shift/reduce conflict for FLOATVAL in state 55 resolved as shift
shift/reduce conflict for INTVAL in state 55 resolved as shift
shift/reduce conflict for LPAREN in state 76 resolved as shift
shift/reduce conflict for VARNAME in state 76 resolved as shift
shift/reduce conflict for NOT in state 76 resolved as shift
shift/reduce conflict for MINUS in state 76 resolved as shift
shift/reduce conflict for BOOLVAL in state 76 resolved as shift
shift/reduce conflict for STRINGVAL in state 76 resolved as shift
shift/reduce conflict for CHARVAL in state 76 resolved as shift
shift/reduce conflict for FLOATVAL in state 76 resolved as shift
shift/reduce conflict for INTVAL in state 76 resolved as shift
shift/reduce conflict for LPAREN in state 90 resolved as shift
shift/reduce conflict for VARNAME in state 90 resolved as shift
shift/reduce conflict for NOT in state 90 resolved as shift
shift/reduce conflict for MINUS in state 90 resolved as shift
shift/reduce conflict for BOOLVAL in state 90 resolved as shift
shift/reduce conflict for STRINGVAL in state 90 resolved as shift
shift/reduce conflict for CHARVAL in state 90 resolved as shift
shift/reduce conflict for FLOATVAL in state 90 resolved as shift
shift/reduce conflict for INTVAL in state 90 resolved as shift